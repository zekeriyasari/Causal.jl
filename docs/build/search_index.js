var documenterSearchIndex = {"docs":
[{"location":"manual/connections/link/#Links-1","page":"Links","title":"Links","text":"","category":"section"},{"location":"manual/connections/link/#","page":"Links","title":"Links","text":"DocTestSetup  = quote\n    using Jusdl\nend","category":"page"},{"location":"manual/connections/link/#","page":"Links","title":"Links","text":"Links are built on top of  Channels of Julia. They are used as communication primitives for Tasks of Julia. A Link basically includes a Channel and a Buffer. The mode of the buffer is Cyclic.(see Buffer Modes for information on buffer modes). Every item sent through a Link is sent through the channel of the Link and written to the Buffer so that all the data flowing through a Link is recorded. The data transmitted through a Link can be of any Julia type, even if user-defined types. ","category":"page"},{"location":"manual/connections/link/#Construction-of-Links-1","page":"Links","title":"Construction of Links","text":"","category":"section"},{"location":"manual/connections/link/#","page":"Links","title":"Links","text":"The construction of a Link is very simple: just specify its buffer length and element type.","category":"page"},{"location":"manual/connections/link/#","page":"Links","title":"Links","text":"Link","category":"page"},{"location":"manual/connections/link/#Jusdl.Connections.Link","page":"Links","title":"Jusdl.Connections.Link","text":"Link{T}([ln::Int=64]) where T\n\nConstructs a Link with element type T and buffer length ln. The buffer element type of T and mode is Cyclic.\n\n\n\n\n\n","category":"type"},{"location":"manual/connections/link/#","page":"Links","title":"Links","text":"Here, are some examples.","category":"page"},{"location":"manual/connections/link/#","page":"Links","title":"Links","text":"using Jusdl # hide \nl1 = Link{Int}(5)\nl2 = Link{Matrix{Float64}}(10)","category":"page"},{"location":"manual/connections/link/#","page":"Links","title":"Links","text":"Similar to the case of Buffers, the data type that can flow the Link can be any Julia type, even a user-defined type. ","category":"page"},{"location":"manual/connections/link/#","page":"Links","title":"Links","text":"using Jusdl # hide\nstruct Object\n    x::Int \nend \nl = Link{Object}(3)     # A `Link` that with element type `Object` with buffer size `3`.","category":"page"},{"location":"manual/connections/link/#Connection-and-Disconnection-of-Links-1","page":"Links","title":"Connection and Disconnection of Links","text":"","category":"section"},{"location":"manual/connections/link/#","page":"Links","title":"Links","text":"Links can be connected to each other so that data can flow from one link to another. The flows from link l1 to l2, then l1 is said to drive l2 and l1 is called as master and l2 is called as slave. A Link can have more than one slave but can have just one master. When a Links is initialized, it has no master and slaves.","category":"page"},{"location":"manual/connections/link/#","page":"Links","title":"Links","text":"connect ","category":"page"},{"location":"manual/connections/link/#Jusdl.Connections.connect","page":"Links","title":"Jusdl.Connections.connect","text":"connect(master::Link, slave::Link)\n\nConnects master to slave. When connected, the flow is from master to slave.\n\nExample\n\njulia> l1, l2 = Link(), Link();\n\njulia> isconnected(l1, l2)\nfalse\n\njulia> connect(l1, l2)\n\njulia> isconnected(l1, l2)\ntrue\n\n\n\n\n\nconnect(master::AbstractVector{<:Link}, slave::AbstractVector{<:Link})\n\nConnect master links to slave links by applying one-to-one matching of master links to slave links.\n\n\n\n\n\nconnect(links...)\n\nConnect each link of links in the form of a path.\n\nExample\n\njulia> ls = [Link() for i = 1 : 3];\n\njulia> map(i -> isconnected(ls[i], ls[i + 1]), 1 : 2)\n2-element Array{Bool,1}:\n 0\n 0\n\njulia> connect(ls...)\n\njulia> map(i -> isconnected(ls[i], ls[i + 1]), 1 : 2)\n2-element Array{Bool,1}:\n 1\n 1\n\n\n\n\n\n","category":"function"},{"location":"manual/connections/link/#","page":"Links","title":"Links","text":"Similarly Links can be disconnected. ","category":"page"},{"location":"manual/connections/link/#","page":"Links","title":"Links","text":"disconnect","category":"page"},{"location":"manual/connections/link/#Jusdl.Connections.disconnect","page":"Links","title":"Jusdl.Connections.disconnect","text":"disconnect(link1::Link, link2::Link)\n\nDisconnects link1 and link2. The order of arguments is not important. \n\nExample\n\njulia> ls = [Link() for i = 1 : 2];\n\njulia> connect(ls[1], ls[2])\n\njulia> disconnect(ls[1], ls[2])\n\njulia> isconnected(ls[1], ls[2])\nfalse\n\n\n\n\n\n","category":"function"},{"location":"manual/connections/link/#","page":"Links","title":"Links","text":"warning: Warning\nNote that the order or arguments is important when the links are connected. connect(l1, l2) connects l1 and l2 such that l1 drives l2, i.e., data flows from l1 to l2. In other words, l1 is the master link and l2 is the slave link. However, the order of arguments is not important when the links are disconnected. disconnect(l1, l2) does the same thing with disconnect(l2, l1), i.e., it justs breaks the connection between l2 and l1.","category":"page"},{"location":"manual/connections/link/#Data-Flow-through-Links-1","page":"Links","title":"Data Flow through Links","text":"","category":"section"},{"location":"manual/connections/link/#","page":"Links","title":"Links","text":"The data can be read from and written into Links if active tasks are bound to them. Links can be thought of a pipe. In order to write data to a Link from one of its ends, a task that reads written data from the other end must be bounded to the Link. Similarly, in order to read data from one of the Link from one of its end, a task that writes the read data must be bound to the Link. Reading from and writing to Link is carried out with take! and put! functions. For more clarity, let us see some example. ","category":"page"},{"location":"manual/connections/link/#","page":"Links","title":"Links","text":"Let us first construct a Link,","category":"page"},{"location":"manual/connections/link/#","page":"Links","title":"Links","text":"using Jusdl # hide\nl = Link{Float64}(5)","category":"page"},{"location":"manual/connections/link/#","page":"Links","title":"Links","text":"l is a Link with a buffer length of 5 and element type of Float64. Not that the l is open, but it is not ready for data reading or writing. To write data, we must bound a task that reads the written data.","category":"page"},{"location":"manual/connections/link/#","page":"Links","title":"Links","text":"function reader(link::Link)  # Define job.\n    while true\n        val = take!(link)\n        val === missing && break  # Poison-pill the tasks to terminate safely.\n    end\nend\nt = @async reader(l)","category":"page"},{"location":"manual/connections/link/#","page":"Links","title":"Links","text":"The reader is defined such that the data written from one end of l is read until the data is missing. Now, we have runnable task t. This means the l is ready for data writing. ","category":"page"},{"location":"manual/connections/link/#","page":"Links","title":"Links","text":"put!(l, 1.)\nput!(l, 2.)","category":"page"},{"location":"manual/connections/link/#","page":"Links","title":"Links","text":"To terminate the task, we must write missing to l.","category":"page"},{"location":"manual/connections/link/#","page":"Links","title":"Links","text":"put!(l, missing)  # Terminate the task \nt   # Show that the `t` is terminated.","category":"page"},{"location":"manual/connections/link/#","page":"Links","title":"Links","text":"Note that the data flown through the l is written to its buffer. ","category":"page"},{"location":"manual/connections/link/#","page":"Links","title":"Links","text":"l.buffer.data","category":"page"},{"location":"manual/connections/link/#","page":"Links","title":"Links","text":"When ever the bound task to the l is runnable, the data can be written to l. That is, the data length that can be written to l is not limited by the buffer length of l. But, beware that the buffer of Linkss are Cyclic. That means, when the buffer is full, its data is overwritten.","category":"page"},{"location":"manual/connections/link/#","page":"Links","title":"Links","text":"l = Link(5)\nt = @async reader(l)\nfor item in 1. : 10.\n    put!(l, item)\n    @show l.buffer.data\nend","category":"page"},{"location":"manual/connections/link/#","page":"Links","title":"Links","text":"The case is very similar to read data from l. Again a runnable task is bound the l ","category":"page"},{"location":"manual/connections/link/#","page":"Links","title":"Links","text":"using Jusdl # hide\nl = Link(5)\nfunction writer(link::Link, vals)\n    for val in vals\n        put!(link, val)\n    end\nend\nt = @async writer(l, 1.:5.)\nbind(l, t)\ntake!(l)\ntake!(l)","category":"page"},{"location":"manual/connections/link/#","page":"Links","title":"Links","text":"It is possible to read data from l until t is active. To read all the data at once, collect can be used. ","category":"page"},{"location":"manual/connections/link/#","page":"Links","title":"Links","text":"t   \ncollect(l)\nt  # Show that `t` is terminated.","category":"page"},{"location":"manual/connections/link/#Full-API-1","page":"Links","title":"Full API","text":"","category":"section"},{"location":"manual/connections/link/#","page":"Links","title":"Links","text":"Connections.put!\nConnections.take!\nConnections.close\nConnections.isopen\nConnections.isreadable\nConnections.iswritable\nConnections.isfull \nConnections.isconnected\nConnections.hasslaves \nConnections.hasmaster \nConnections.getmaster \nConnections.getslaves \nConnections.snapshot \nConnections.Connections.UnconnectedLinkError\nConnections.Connections.Pin\nConnections.findflow \nConnections.insert \nConnections.release\nConnections.bind\nConnections.collect\nConnections.launch ","category":"page"},{"location":"manual/connections/link/#Base.put!","page":"Links","title":"Base.put!","text":"put!(link::Link, val)\n\nPuts val to link. val is handed over to the channel of link. val is also written in to the buffer of link.\n\nwarning: Warning\nlink must be writable to put val. See launch\n\nExample\n\njulia> l = Link();\n\njulia> t = launch(l);  # To be able to put values, `l` must be bound to a runnable task.\n\njulia> put!(l, 1.)\n┌ Info: Took \n└   val = 1.0\n1.0\n\n\n\n\n\nput!(bus::Bus, vals)\n\nPuts vals to bus. Each item in vals is putted to the links of the bus.\n\nwarning: Warning\nThe bus must be writable to be read. That is, there must be a runnable tasks bound to links of the bus that reads data from bus. See launch\n\nExample\n\njulia> b = Bus(2);\n\njulia> t = launch(b);\n\njulia> put!(b, [1., 2.])\n┌ Info: Took \n└   val = 1.0\n┌ Info: Took \n└   val = 2.0\n2-element Array{Float64,1}:\n 1.0\n 2.0\n\n\n\n\n\n","category":"function"},{"location":"manual/connections/link/#Base.take!","page":"Links","title":"Base.take!","text":"take!(link::Link)\n\nTake an element from link.\n\nwarning: Warning\nlink must be readable to take value. See launch\n\nExample\n\njulia> l = Link(5);\n\njulia> t = launch(l, 1. : 5.);\n\njulia> for i in 1 : 5\n       @show take!(l)\n       end\ntake!(l) = 1.0\ntake!(l) = 2.0\ntake!(l) = 3.0\ntake!(l) = 4.0\ntake!(l) = 5.0\n\n\n\n\n\ntake!(bus::Bus)\n\nTakes an element from bus. Each link of the bus is a read and a vector containing the results is returned.\n\nwarning: Warning\nThe bus must be readable to be read. That is, there must be a runnable tasks bound to links of the bus that writes data to bus. See launch\n\nExample\n\njulia> b = Bus(2);\n\njulia> t = launch(b, [[rand() for i = 1 : 5] for j = 1 : 2])\n2-element Array{Task,1}:\n Task (runnable) @0x00007f9634734280\n Task (runnable) @0x00007f96347344f0\n\njulia> take!(b)\n2-element Array{Float64,1}:\n 0.6216364091492494\n 0.0781964275368685\n\n\n\n\n\n","category":"function"},{"location":"manual/connections/link/#Base.close","page":"Links","title":"Base.close","text":"close(link)\n\nCloses link. All the task bound the link is also terminated safely. When closed, data cannot ben into or read from the link.\n\nExample\n\njulia> l  = Link();\n\njulia> t = launch(l);\n\njulia> put!(l, 1.)\n┌ Info: Took \n└   val = 1.0\n1.0\n\njulia> close(l)\n\njulia> put!(l, 1.)\nERROR: InvalidStateException(\"Channel is closed.\", :closed)\nStacktrace:\n [1] check_channel_state at ./channels.jl:167 [inlined]\n [2] put! at ./channels.jl:323 [inlined]\n [3] put!(::Link{Union{Missing, Float64}}, ::Float64) at /home/sari/.julia/dev/Jusdl/src/connections/link.jl:64\n [4] top-level scope at REPL[99]:1\n\n\n\n\n\n","category":"function"},{"location":"manual/connections/link/#Base.isopen","page":"Links","title":"Base.isopen","text":"open(link::Link)\n\nReturns true if link is open. A link is open if its channel is open.\n\n\n\n\n\n","category":"function"},{"location":"manual/connections/link/#Base.isreadable","page":"Links","title":"Base.isreadable","text":"isreadable(link::Link)\n\nReturns true if link is readable. When link is readable, data can be read from link with take function.\n\n\n\n\n\n","category":"function"},{"location":"manual/connections/link/#Base.iswritable","page":"Links","title":"Base.iswritable","text":"writable(link::Link)\n\nReturns true if link is writable. When link is writable, data can be written into link with put function.\n\n\n\n\n\n","category":"function"},{"location":"manual/connections/link/#Jusdl.Connections.isfull","page":"Links","title":"Jusdl.Connections.isfull","text":"isfull(link::Link)\n\nReturns true if the buffer of link is full.\n\n\n\n\n\n","category":"function"},{"location":"manual/connections/link/#Jusdl.Connections.isconnected","page":"Links","title":"Jusdl.Connections.isconnected","text":"isconnected(link1, link2)\n\nReturns true if link1 is connected to link2. The order of the arguments are not important.\n\n\n\n\n\n","category":"function"},{"location":"manual/connections/link/#Jusdl.Connections.hasslaves","page":"Links","title":"Jusdl.Connections.hasslaves","text":"hasslaves(link::Link)\n\nReturns true if link has slave links.\n\n\n\n\n\n","category":"function"},{"location":"manual/connections/link/#Jusdl.Connections.hasmaster","page":"Links","title":"Jusdl.Connections.hasmaster","text":"hasmaster(link::Link)\n\nReturns true if link has a master link.\n\n\n\n\n\n","category":"function"},{"location":"manual/connections/link/#Jusdl.Connections.getmaster","page":"Links","title":"Jusdl.Connections.getmaster","text":"getmaster(link::Link)\n\nReturns the master of link.\n\n\n\n\n\n","category":"function"},{"location":"manual/connections/link/#Jusdl.Connections.getslaves","page":"Links","title":"Jusdl.Connections.getslaves","text":"getslaves(link::Link)\n\nReturns the slaves of link.\n\n\n\n\n\n","category":"function"},{"location":"manual/connections/link/#Jusdl.Connections.snapshot","page":"Links","title":"Jusdl.Connections.snapshot","text":"snapshot(link::Link)\n\nReturns all the data of the buffer of link.\n\n\n\n\n\n","category":"function"},{"location":"manual/connections/link/#Jusdl.Connections.UnconnectedLinkError","page":"Links","title":"Jusdl.Connections.UnconnectedLinkError","text":"UnconnectedLinkError <: Exception\n\nException thrown when the links are not connected to each other.\n\n\n\n\n\n","category":"type"},{"location":"manual/connections/link/#Jusdl.Connections.Pin","page":"Links","title":"Jusdl.Connections.Pin","text":"Pin()\n\nConstructs a Pin. A Pin is the auxilary type to monitor connection status of Links. See Link\n\n\n\n\n\n","category":"type"},{"location":"manual/connections/link/#Jusdl.Connections.findflow","page":"Links","title":"Jusdl.Connections.findflow","text":"findflow(link1::Link, link2::Link)\n\nReturns a tuple of (masterlink, slavelink) where masterlink is the link that drives the other and slavelink is the link that is driven by the other.\n\nExample\n\njulia> ls = [Link() for i = 1 : 2];\n\njulia> connect(ls[1], ls[2])\n\njulia> findflow(ls[2], ls[1]) .== (ls[1], ls[2])\n(true, true)\n\n\n\n\n\n","category":"function"},{"location":"manual/connections/link/#Jusdl.Connections.insert","page":"Links","title":"Jusdl.Connections.insert","text":"insert(master::Link, slave::Link, new::Link)\n\nInserts the new link between the master link and slave link. The master is connected to new, and new is connected to slave.\n\nExample\n\njulia> ls = [Link() for i = 1 : 3];  \n\njulia> connect(ls[1], ls[2]) \n\njulia> insert(ls[1], ls[2], ls[3])\n\njulia> isconnected(ls[1], ls[2])\nfalse\n\njulia> isconnected(ls[1], ls[3]) && isconnected(ls[3], ls[2])\ntrue\n\n\n\n\n\n","category":"function"},{"location":"manual/connections/link/#Jusdl.Connections.release","page":"Links","title":"Jusdl.Connections.release","text":"release(link::Link)\n\nRelease all the slave links of link. That is, all the slave links of link is disconnected.\n\nExample\n\njulia> ls = [Link() for i = 1 : 5];\n\njulia> foreach(l -> connect(ls[1], l), ls[2:5])\n\njulia> map(l -> isconnected(ls[1], l), ls[2:5])\n4-element Array{Bool,1}:\n 1\n 1\n 1\n 1\n\njulia> release(ls[1])  # Release all the slaves.\n\njulia> map(l -> isconnected(ls[1], l), ls[2:5])\n4-element Array{Bool,1}:\n 0\n 0\n 0\n 0\n\n\n\n\n\n","category":"function"},{"location":"manual/connections/link/#Base.bind","page":"Links","title":"Base.bind","text":"bind(link::Link, task::Task)\n\nBinds task to link. When task is done link is closed.\n\n\n\n\n\n","category":"function"},{"location":"manual/connections/link/#Base.collect","page":"Links","title":"Base.collect","text":"collect(link::Link)\n\nCollects all the available data on the link.\n\n\n\n\n\n","category":"function"},{"location":"manual/connections/link/#Jusdl.Connections.launch","page":"Links","title":"Jusdl.Connections.launch","text":"launch(link::Link)\n\nConstructs a taker task and binds it to link. The taker task reads the data and prints an info message until missing is read from the link.\n\n\n\n\n\nlaunch(link:Link, valrange)\n\nConstructs a putter task and binds it to link. putter tasks puts the data in valrange.\n\n\n\n\n\n","category":"function"},{"location":"manual/utilities/callback/#Callback-1","page":"Callback","title":"Callback","text":"","category":"section"},{"location":"manual/utilities/callback/#","page":"Callback","title":"Callback","text":"DocTestSetup  = quote\n    using Jusdl\nend","category":"page"},{"location":"manual/utilities/callback/#","page":"Callback","title":"Callback","text":"Callbacks are used to monitor the existence of a specific events and if that specific event occurs, some other special jobs are invoked. Callbacks are intended to provide additional monitoring capability to any user-defined composite types. As such, Callbacks are generaly fields of user defined composite types objects. When a Callback is called, if the Callback is enabled and its condition function returns true, then its action function is invoked. ","category":"page"},{"location":"manual/utilities/callback/#A-Simple-Example-1","page":"Callback","title":"A Simple Example","text":"","category":"section"},{"location":"manual/utilities/callback/#","page":"Callback","title":"Callback","text":"Let's define a test object first that has a field named x of type Int and named callback of type Callback. ","category":"page"},{"location":"manual/utilities/callback/#","page":"Callback","title":"Callback","text":"julia> mutable struct TestObject\n       x::Int\n       callback::Callback\n       end","category":"page"},{"location":"manual/utilities/callback/#","page":"Callback","title":"Callback","text":"To construct an instance of TestObject, we need to construct a Callback. For that purpose, condition and action function must be defined. For this example, condition checks whether the x field is positive, and action prints a simple message saying that the x field is positive.","category":"page"},{"location":"manual/utilities/callback/#","page":"Callback","title":"Callback","text":"julia> condition(testobject) = testobject.x > 0 \ncondition (generic function with 1 method)\n\njulia> action(testobject) = println(\"testobject.x is greater than zero\") \naction (generic function with 1 method)","category":"page"},{"location":"manual/utilities/callback/#","page":"Callback","title":"Callback","text":"Now a test object can be constructed","category":"page"},{"location":"manual/utilities/callback/#","page":"Callback","title":"Callback","text":"julia> testobject = TestObject(-1, Callback(condition, action))  \nTestObject(-1, Callback{typeof(condition),typeof(action)}(condition, action, true, \"dac6f9eb-6daa-4622-a8fa-623f0f88780c\"))","category":"page"},{"location":"manual/utilities/callback/#","page":"Callback","title":"Callback","text":"If the callback is called, no action is performed since the condition function returns false. Note the argument sent to the callback. The instance of the TestObject to which the callback is a bound.","category":"page"},{"location":"manual/utilities/callback/#","page":"Callback","title":"Callback","text":"julia> testobject.callback(testobject) ","category":"page"},{"location":"manual/utilities/callback/#","page":"Callback","title":"Callback","text":"Now mutate the test object so that condition returns true.","category":"page"},{"location":"manual/utilities/callback/#","page":"Callback","title":"Callback","text":"julia> testobject.x = 3   \n3","category":"page"},{"location":"manual/utilities/callback/#","page":"Callback","title":"Callback","text":"Now, if the callback is called, since the condition returns true and the callback is enabled, the action is invoked.","category":"page"},{"location":"manual/utilities/callback/#","page":"Callback","title":"Callback","text":"julia> testobject.callback(testobject) \ntestobject.x is greater than zero","category":"page"},{"location":"manual/utilities/callback/#Full-API-1","page":"Callback","title":"Full API","text":"","category":"section"},{"location":"manual/utilities/callback/#","page":"Callback","title":"Callback","text":"Callback\nenable!\ndisable!\nisenabled\naddcallback\ndeletecallback","category":"page"},{"location":"manual/utilities/callback/#Jusdl.Utilities.Callback","page":"Callback","title":"Jusdl.Utilities.Callback","text":"Callback(condition, action)\n\nConstructs a Callback from condition and action. The condition and action must be a single-argument functions. condition returns true if the condition it checks occurs, otherwise ite returns false. action is performs the specific action for which the Callback the callback is contructed. A Callback can be called by passing its single argument which is mostly bound to the Callback.\n\nExample\n\njulia> struct Object  # Define a dummy type.\n       x::Int \n       clb::Callback \n       end \n\njulia> cond(obj) = obj.x > 0  # Define callback condition.\ncond (generic function with 1 method)\n\njulia> action(obj) = println(\"Printing the object \", obj) # Define callback action.\naction (generic function with 1 method)\n\njulia> obj = Object(1, Callback(cond, action))  # Construct an `Object` instance with `Callback`.\nObject(1, Callback(condition:cond, action:action))\n\njulia> obj.clb(obj)  # Call the callback bound `obj`.\nPrinting the object Object(1, Callback(condition:cond, action:action))\n\n\n\n\n\n","category":"type"},{"location":"manual/utilities/callback/#Jusdl.Utilities.enable!","page":"Callback","title":"Jusdl.Utilities.enable!","text":"enable!(clb::Callback)\n\nEnables clb.\n\n\n\n\n\n","category":"function"},{"location":"manual/utilities/callback/#Jusdl.Utilities.disable!","page":"Callback","title":"Jusdl.Utilities.disable!","text":"disable!(clb::Callback)\n\nDisables clb.\n\n\n\n\n\n","category":"function"},{"location":"manual/utilities/callback/#Jusdl.Utilities.isenabled","page":"Callback","title":"Jusdl.Utilities.isenabled","text":"isenabled(clb::Callback)\n\nReturns true if clb is enabled. Otherwise, returns false.\n\n\n\n\n\n","category":"function"},{"location":"manual/utilities/callback/#Jusdl.Utilities.addcallback","page":"Callback","title":"Jusdl.Utilities.addcallback","text":"addcallback(obj, clb::Callback, priority::Int)\n\nAdds clb to callback vector of obj which is assumed the have a callback list which is a vector of callback.\n\nExample\n\njulia> mutable struct Object \n       x::Int \n       callbacks::Vector{Callback}\n       Object(x::Int) = new(x, Callback[])\n       end \n\njulia> obj = Object(5)\nObject(5, Callback[])\n\njulia> condition(val) = val.x == 5\ncondition (generic function with 1 method)\n\njulia> action(val) = @show val.x \naction (generic function with 1 method)\n\njulia> addcallback(obj, Callback(condition, action))\nObject(5, Callback[Callback(condition:condition, action:action)])\n\njulia> obj.callbacks(obj)\nval.x = 5\n\n\n\n\n\n","category":"function"},{"location":"manual/utilities/callback/#Jusdl.Utilities.deletecallback","page":"Callback","title":"Jusdl.Utilities.deletecallback","text":"deletecallback(obj, idx::Int)\n\nDeletes the one of the callbacks of obj at index idx.\n\njulia> struct Object \n       x::Int \n       callbacks::Vector{Callback}\n       end\n\njulia> clb1 = Callback(val -> true, val -> nothing);\n\njulia> clb2 = Callback(val -> false, val -> nothing);\n\njulia> obj = Object(5, [clb1, clb2]);\n\njulia> deletecallback(obj, 2);\n\njulia> length(obj.callbacks) == 1\ntrue\n\n\n\n\n\n","category":"function"},{"location":"manual/utilities/buffers/#Buffer-1","page":"Buffer","title":"Buffer","text":"","category":"section"},{"location":"manual/utilities/buffers/#","page":"Buffer","title":"Buffer","text":"DocTestSetup  = quote\n    using Jusdl\n    import Utilities: BufferMode, LinearMode, CyclicMode\nend","category":"page"},{"location":"manual/utilities/buffers/#","page":"Buffer","title":"Buffer","text":"Buffer is a primitive to buffer the data. Data can be of any Julia type. Data can be read from and written into a buffer, and the mode of the buffer determines the way to read from and write into the buffers. ","category":"page"},{"location":"manual/utilities/buffers/#Buffer-Modes-1","page":"Buffer","title":"Buffer Modes","text":"","category":"section"},{"location":"manual/utilities/buffers/#","page":"Buffer","title":"Buffer","text":"Buffer mode determines the way the data is read from and written into a Buffer. ","category":"page"},{"location":"manual/utilities/buffers/#","page":"Buffer","title":"Buffer","text":"Utilities.BufferMode \nUtilities.LinearMode \nUtilities.CyclicMode","category":"page"},{"location":"manual/utilities/buffers/#Jusdl.Utilities.BufferMode","page":"Buffer","title":"Jusdl.Utilities.BufferMode","text":"BufferMode\n\nAbstract type for buffer mode. Subtypes of BufferMode is CyclicMode and LinearMode.\n\n\n\n\n\n","category":"type"},{"location":"manual/utilities/buffers/#Jusdl.Utilities.LinearMode","page":"Buffer","title":"Jusdl.Utilities.LinearMode","text":"LinearMode <: BufferMode\n\nAbstract type of linear buffer modes. See Normal, Lifo, Fifo\n\n\n\n\n\n","category":"type"},{"location":"manual/utilities/buffers/#Jusdl.Utilities.CyclicMode","page":"Buffer","title":"Jusdl.Utilities.CyclicMode","text":"CyclicMode <: BufferMode\n\nAbstract type of cyclic buffer modes. See Cyclic\n\n\n\n\n\n","category":"type"},{"location":"manual/utilities/buffers/#","page":"Buffer","title":"Buffer","text":"There are four different buffer modes.","category":"page"},{"location":"manual/utilities/buffers/#","page":"Buffer","title":"Buffer","text":"Normal\nCyclic\nLifo \nFifo","category":"page"},{"location":"manual/utilities/buffers/#Jusdl.Utilities.Normal","page":"Buffer","title":"Jusdl.Utilities.Normal","text":"Normal <: LinearMode\n\nLinearMode buffer mode. The data is written to buffer until the buffer is full. When it is full, no more data is written to the buffer. When read, the data written last is returned and the returned data is not deleted from the internal container of the buffer. \n\n\n\n\n\n","category":"type"},{"location":"manual/utilities/buffers/#Jusdl.Utilities.Cyclic","page":"Buffer","title":"Jusdl.Utilities.Cyclic","text":"Cyclic <: CyclicMode\n\nCyclic buffer mode. The data is written to buffer until the buffer is full. When the buffer is full, new data is written by overwriting the data available in the buffer starting from the beginning of the buffer. When the buffer is read, the element written last is returned and the returned element is not deleted from the buffer.\n\n\n\n\n\n","category":"type"},{"location":"manual/utilities/buffers/#Jusdl.Utilities.Lifo","page":"Buffer","title":"Jusdl.Utilities.Lifo","text":"Lifo <: LinearMode\n\nLifo (Last-in-first-out) buffer mode. This type of buffer is a last-in-first-out buffer. Data is written to the buffer until the buffer is full. When the buffer is full, no more element can be written into the buffer. When read, the last element written into buffer is returned. The returned element is deleted from the buffer.\n\n\n\n\n\n","category":"type"},{"location":"manual/utilities/buffers/#Jusdl.Utilities.Fifo","page":"Buffer","title":"Jusdl.Utilities.Fifo","text":"Fifo <: LinearMode\n\nFifo (First-in-last-out) buffer mode. This type of buffer is a first-in-first-out buffer. The data is written to the buffer until the buffer is full. When the buffer is full, no more element can be written into the buffer. When read, the first element written into the buffer is returned. The returned element is deleted from the buffer. \n\n\n\n\n\n","category":"type"},{"location":"manual/utilities/buffers/#Buffer-Constructors-1","page":"Buffer","title":"Buffer Constructors","text":"","category":"section"},{"location":"manual/utilities/buffers/#","page":"Buffer","title":"Buffer","text":"The Buffer construction is very similar to the construction of arrays in Julia. Just specify the mode, element type and length of the buffer. Here are the main Buffer constructors: ","category":"page"},{"location":"manual/utilities/buffers/#","page":"Buffer","title":"Buffer","text":"Buffer","category":"page"},{"location":"manual/utilities/buffers/#Jusdl.Utilities.Buffer","page":"Buffer","title":"Jusdl.Utilities.Buffer","text":"Buffer{M}(::Type{T}, ln::Int) where {M, T}\n\nConstructs a Buffer of length ln with element type of T. M is the mode of the Buffer that determines how data is to read from and written into the Buffer.  There exists for different buffer modes: \n\nNormal: See Normal\nCyclic: See Cyclic\nLifo: See Lifo\nFifo: See Fifo\n\nThe default mode for Buffer is Cyclic and default element type is Float64.\n\nBuffer(::Type{T}, ln::Int) where T\n\nConstructs a Buffer of length ln and with element type of T. The mode of the buffer is Cyclic.\n\nBuffer{M}(ln::Int) where M\n\nConstructs a Buffer of length of ln and with mode M. M can be Normal, Cyclic, Fifo and Lifo. The element type of the Buffer is Float64.\n\nBuffer(ln::Int)\n\nConstructs a Buffer of length ln with mode Cyclic and element type of Float64.\n\n\n\n\n\n","category":"type"},{"location":"manual/utilities/buffers/#","page":"Buffer","title":"Buffer","text":"warning: Warning\nNote that Buffer is one dimensional. That is, the length of the data must be specified when constructing a Buffer. ","category":"page"},{"location":"manual/utilities/buffers/#","page":"Buffer","title":"Buffer","text":"warning: Warning\nNote that when a Buffer is initialized, the internal data of the Buffer is of missing. ","category":"page"},{"location":"manual/utilities/buffers/#","page":"Buffer","title":"Buffer","text":"Let us try some examples. Here are some simple buffer construction.","category":"page"},{"location":"manual/utilities/buffers/#","page":"Buffer","title":"Buffer","text":"using Jusdl # hide\nbuf1 = Buffer{Normal}(Float64, 5)   # Buffer of length `5` with mode `Normal` and element type of `Float64`. \nbuf2 = Buffer{Fifo}(Int, 3)       # Buffer of length `5` with mode `Fifo` and element type of `Int`. \nbuf3 = Buffer(Vector{Int}, 3)       # Buffer of length `5` with mode `Cyclic` and element type of `Vector{Int}`. \nbuf4 = Buffer(Matrix{Float64}, 5)    # Buffer of length `5` with mode `Cyclic` and element type of `Matrix{Float64}`. \nbuf5 = Buffer(5)                    # Buffer of length `5` with mode `Cyclic` and element type of `Float64`.","category":"page"},{"location":"manual/utilities/buffers/#","page":"Buffer","title":"Buffer","text":"Note that the element type of Buffer can be any Julia type, even any user-defined type. Note the following example, ","category":"page"},{"location":"manual/utilities/buffers/#","page":"Buffer","title":"Buffer","text":"using Jusdl #hide \nstruct Object end       # Define a dummy type. \nbuf = Buffer{Normal}(Object, 4)  # Buffer of length `4` with element type `Object`.","category":"page"},{"location":"manual/utilities/buffers/#Writing-Data-into-Buffers-1","page":"Buffer","title":"Writing Data into Buffers","text":"","category":"section"},{"location":"manual/utilities/buffers/#","page":"Buffer","title":"Buffer","text":"Writing data into a Buffer is done with write! function.","category":"page"},{"location":"manual/utilities/buffers/#","page":"Buffer","title":"Buffer","text":"write!","category":"page"},{"location":"manual/utilities/buffers/#Jusdl.Utilities.write!","page":"Buffer","title":"Jusdl.Utilities.write!","text":"write!(buf::Buffer{M, T}, val) where {M, T}\n\nWrites val into buf. Writing is carried occurding the mode M of buf. See Normal, Cyclic, Lifo, Fifo for buffer modes. \n\nExample\n\njulia> buf = Buffer(3)\nBuffer(mode:Cyclic, eltype:Union{Missing, Float64}, length:3, index:1, state:empty)\n\njulia> buf.data  # Initailly all the elements of `buf` is missing.\n3-element Array{Union{Missing, Float64},1}:\n missing\n missing\n missing\n\njulia> write!(buf, 3.)\n3.0\n\njulia> buf.data\n3-element Array{Union{Missing, Float64},1}:\n 3.0     \n  missing\n  missing\n\n\n\n\n\n","category":"function"},{"location":"manual/utilities/buffers/#","page":"Buffer","title":"Buffer","text":"Recall that when the buffer is full, no more data can be written into the buffer if the buffer mode is of type LinearMode. ","category":"page"},{"location":"manual/utilities/buffers/#","page":"Buffer","title":"Buffer","text":"using Jusdl # hide\nnormalbuf = Buffer{Normal}(3)\nfill!(normalbuf, 1.)\nnormalbuf.data \nwrite!(normalbuf, 1.)","category":"page"},{"location":"manual/utilities/buffers/#","page":"Buffer","title":"Buffer","text":"This situation is the same for Lifo and Fifo buffers, but not the case for Cyclic buffer. ","category":"page"},{"location":"manual/utilities/buffers/#","page":"Buffer","title":"Buffer","text":"using Jusdl # hide\nnormalbuf = Buffer{Cyclic}(3)\nfill!(normalbuf, 1.)\nnormalbuf.data \nwrite!(normalbuf, 3.)\nwrite!(normalbuf, 4.)","category":"page"},{"location":"manual/utilities/buffers/#","page":"Buffer","title":"Buffer","text":"warning: Warning\nSince when a Buffer is constructed, it is empty, no data is written to it. But it is initialized with missing data. Thus, the element type of buffer of type Buffer{M, T} where {M, T} is Union{Missing, T} where T. Benchmarks that has been carried out shows that there is no performance bottle neck is such design since Julia's compiler can compile optimized code for such a small unions. Therefore it is possible to write missing into a buffer of type Buffer{M,T} where {M,T}.","category":"page"},{"location":"manual/utilities/buffers/#Reading-Data-from-Buffers-1","page":"Buffer","title":"Reading Data from Buffers","text":"","category":"section"},{"location":"manual/utilities/buffers/#","page":"Buffer","title":"Buffer","text":"Reading data from a Buffer is done with read function.","category":"page"},{"location":"manual/utilities/buffers/#","page":"Buffer","title":"Buffer","text":"read","category":"page"},{"location":"manual/utilities/buffers/#Base.read","page":"Buffer","title":"Base.read","text":"read(buf::Buffer)\n\nReads an element from buf. Reading is performed according to the mode of buf. See Normal, Cyclic, Lifo, Fifo for buffer modes. \n\nExample\n\njulia> buf = Buffer{Fifo}(3)\nBuffer(mode:Fifo, eltype:Union{Missing, Float64}, length:3, index:1, state:empty)\n\njulia> for val in 1 : 3. \n       write!(buf, val)\n       @show buf.data\n       end \nbuf.data = Union{Missing, Float64}[1.0, missing, missing]\nbuf.data = Union{Missing, Float64}[1.0, 2.0, missing]\nbuf.data = Union{Missing, Float64}[1.0, 2.0, 3.0]\n\njulia> for i in 1 : 3 \n       item = read(buf)\n       @show (item, buf.data)\n       end\n(item, buf.data) = (1.0, Union{Missing, Float64}[2.0, 3.0, missing])\n(item, buf.data) = (2.0, Union{Missing, Float64}[3.0, missing, missing])\n(item, buf.data) = (3.0, Union{Missing, Float64}[missing, missing, missing])\n\n\n\n\n\n","category":"function"},{"location":"manual/utilities/buffers/#AbstractArray-Interface-of-Buffers-1","page":"Buffer","title":"AbstractArray Interface of Buffers","text":"","category":"section"},{"location":"manual/utilities/buffers/#","page":"Buffer","title":"Buffer","text":"A Buffer can be indexed using the similar syntax of arrays in Julia. That is, getindex and setindex! methods can be used with known Julia syntax. i.e. getindex(buf, idx) is equal to buf[idx] and setindex(buf, val, idx) is equal to buf[idx] = val.","category":"page"},{"location":"manual/utilities/buffers/#","page":"Buffer","title":"Buffer","text":"using Jusdl  # hide\nbuf = Buffer(5)\nsize(buf)\nlength(buf)\nfor val in 1 : 5 \n    write!(buf, 2val)\nend \nbuf[1]\nbuf[3:4]\nbuf[[3, 5]]\nbuf[end]\nbuf[1] = 5 \nbuf[3:5] = [7, 8, 9]","category":"page"},{"location":"manual/utilities/buffers/#Full-API-1","page":"Buffer","title":"Full API","text":"","category":"section"},{"location":"manual/utilities/buffers/#","page":"Buffer","title":"Buffer","text":"fill!\nisempty\nisfull\ncontent","category":"page"},{"location":"manual/utilities/buffers/#Base.fill!","page":"Buffer","title":"Base.fill!","text":"fill!(buf::Buffer{M, T}, val::T) where {M,T}\n\nWrites val into buf until buf is full.\n\n\n\n\n\n","category":"function"},{"location":"manual/utilities/buffers/#Base.isempty","page":"Buffer","title":"Base.isempty","text":"isempty(buf::Buffer)\n\nReturns true if buf is empty.\n\n\n\n\n\n","category":"function"},{"location":"manual/utilities/buffers/#Jusdl.Utilities.isfull","page":"Buffer","title":"Jusdl.Utilities.isfull","text":"isfull(buf::Buffer)\n\nReturns true if buf is full.\n\n\n\n\n\n","category":"function"},{"location":"manual/utilities/buffers/#Jusdl.Utilities.content","page":"Buffer","title":"Jusdl.Utilities.content","text":"content(buf, [flip=true])\n\nReturns the current data of buf. If flip is true, the data to be returned is flipped. \n\n\n\n\n\n","category":"function"},{"location":"manual/connections/bus/#Busses-1","page":"Busses","title":"Busses","text":"","category":"section"},{"location":"manual/connections/bus/#","page":"Busses","title":"Busses","text":"A Bus is actually is a bunch of links. Reading from and writing into  data is performed as in the case of Links.","category":"page"},{"location":"manual/connections/bus/#Construction-of-Bus-1","page":"Busses","title":"Construction of Bus","text":"","category":"section"},{"location":"manual/connections/bus/#","page":"Busses","title":"Busses","text":"A Bus is constructed by specifying its element type T, number of links nlinks and the buffer length of its links.","category":"page"},{"location":"manual/connections/bus/#","page":"Busses","title":"Busses","text":"Bus","category":"page"},{"location":"manual/connections/bus/#Jusdl.Connections.Bus","page":"Busses","title":"Jusdl.Connections.Bus","text":"Bus{T}([nlinks::Int=1, [ln::Int=64]]) where T\n\nConstructs a Bus consisting of nlinks links. ln is the buffer length and T is element type of the links.\n\n\n\n\n\n","category":"type"},{"location":"manual/connections/bus/#Data-Flow-through-Busses-1","page":"Busses","title":"Data Flow through Busses","text":"","category":"section"},{"location":"manual/connections/bus/#","page":"Busses","title":"Busses","text":"Data flow through the Busses is very similar to the case in Links. See Data Flow through Links for information about data flow through Links. Runnable tasks must be bound to the links of the busses for data flow through the Bus. Again, put! and take! functions are used to write data from a Bus and read from data from a Bus.","category":"page"},{"location":"manual/connections/bus/#","page":"Busses","title":"Busses","text":"Connections.put!(bus::Bus, vals)\nConnections.take!(bus::Bus)","category":"page"},{"location":"manual/connections/bus/#Base.put!-Tuple{Bus,Any}","page":"Busses","title":"Base.put!","text":"put!(bus::Bus, vals)\n\nPuts vals to bus. Each item in vals is putted to the links of the bus.\n\nwarning: Warning\nThe bus must be writable to be read. That is, there must be a runnable tasks bound to links of the bus that reads data from bus. See launch\n\nExample\n\njulia> b = Bus(2);\n\njulia> t = launch(b);\n\njulia> put!(b, [1., 2.])\n┌ Info: Took \n└   val = 1.0\n┌ Info: Took \n└   val = 2.0\n2-element Array{Float64,1}:\n 1.0\n 2.0\n\n\n\n\n\n","category":"method"},{"location":"manual/connections/bus/#Base.take!-Tuple{Bus}","page":"Busses","title":"Base.take!","text":"take!(bus::Bus)\n\nTakes an element from bus. Each link of the bus is a read and a vector containing the results is returned.\n\nwarning: Warning\nThe bus must be readable to be read. That is, there must be a runnable tasks bound to links of the bus that writes data to bus. See launch\n\nExample\n\njulia> b = Bus(2);\n\njulia> t = launch(b, [[rand() for i = 1 : 5] for j = 1 : 2])\n2-element Array{Task,1}:\n Task (runnable) @0x00007f9634734280\n Task (runnable) @0x00007f96347344f0\n\njulia> take!(b)\n2-element Array{Float64,1}:\n 0.6216364091492494\n 0.0781964275368685\n\n\n\n\n\n","category":"method"},{"location":"manual/connections/bus/#Indexing-and-Iteration-of-Busses-1","page":"Busses","title":"Indexing and Iteration of Busses","text":"","category":"section"},{"location":"manual/connections/bus/#","page":"Busses","title":"Busses","text":"Busses can be indexed similarly to the arrays in Julia. When indexed, corresponding link of the bus is returned.","category":"page"},{"location":"manual/connections/bus/#","page":"Busses","title":"Busses","text":"using Jusdl # hide \nb = Bus(3) \nb[1]\nb[end] \nb[:]\nb[1] = Link()\nb[1:2] = [Link(), Link()]","category":"page"},{"location":"#Jusdl-1","page":"Jusdl","title":"Jusdl","text":"","category":"section"},{"location":"#","page":"Jusdl","title":"Jusdl","text":"This is the official documentation of Jusdl that enables fast and effective systems simulations together with online and offline data analysis. In Jusdl, it is possible to simulate discrete time and continuous time, static or dynamical systems. In particular, it is possible to simulate dynamical systems modeled by different types of differential equations such as ODE (Ordinary Differential Equation), Random Ordinary Differential Equation (RODE), SDE (Stochastic Differential Equation), DDE (Delay Differential Equation) and DAE (Differential Algebraic Equation), and discrete difference equations. During the simulation, the data flowing through the links of the model can processed online and offline and specialized analyzes can be performed. These analyzes can also be enriched with plugins that can easily be defined using the standard Julia library or various Julia packages. The simulation is done with the parallel evolution of the model components individually and sampling sampling time intervals. The individual evolution of the components allows the simulation of the models including the components that are represented by different kinds of mathematical equations while the parallel evolution of components increases the simulation speed. ","category":"page"},{"location":"#Installation-1","page":"Jusdl","title":"Installation","text":"","category":"section"},{"location":"#","page":"Jusdl","title":"Jusdl","text":"Installation of Jusdl is the similar to any Julia package. Just add from the repository [https://imel.eee.deu.edu.tr/git/JuSDL.jl.git]. Start a Julia session and type,","category":"page"},{"location":"#","page":"Jusdl","title":"Jusdl","text":"using Pkg \nPkg.add(PackageSpec(url=\"https://imel.eee.deu.edu.tr/git/JuSDL.jl.git\"))","category":"page"},{"location":"#Table-of-Contents-1","page":"Jusdl","title":"Table of Contents","text":"","category":"section"},{"location":"#","page":"Jusdl","title":"Jusdl","text":"Pages = [\n    \"manual/utilities/callback.md\"\n    \"manual/utilities/buffers.md\"\n    ]","category":"page"},{"location":"#","page":"Jusdl","title":"Jusdl","text":"Pages = [\n    \"manual/connections/link.md\",\n    \"manual/connections/bus.md\"\n    ]","category":"page"},{"location":"#Index-1","page":"Jusdl","title":"Index","text":"","category":"section"},{"location":"#","page":"Jusdl","title":"Jusdl","text":"","category":"page"}]
}
