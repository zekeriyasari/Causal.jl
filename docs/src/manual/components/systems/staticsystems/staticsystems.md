# StaticSystems

## Basic Operation of StaticSystems 
A static system is a system whose output `y` at time `t` depends on the current time `t` and the value of its input `u`. The input-output relation of a static systems is represented by its output function `outputfunc` which is of the form 
```math 
    y = g(u, t)
```
where `g` is the output function `outputfunc`. Note that `outputfunc` is expected to have two inputs, the value `u` of the `input` and the current time `t`. The simulation in `Jusdl` is a clocked-simulation, that is the data flowing through the input and output connections of components is actually sampled at time `t`. Therefore, for example, the system modeled by
```math 
y(t) = g(u(t),t)
```
is actually sampled at clock ticks `t` which is generated by a [`Clock`](@ref). Therefore the sampled system corresponds to
```math 
y[k] = g(u_k, t_k)
```
where ``k`` is ``k_i T_s`` where ``k_i`` is an integer number, ``T_s`` is the sampling interval. ``T_s`` corresponds to sampling time `dt` of [`Clock`](@ref). Thus, the system given above is coded like 
```julia
function g(u, t)
    # Define the relation `y = g(u, t)`
end
```

For further clarity, let us continue with a case study. Consider the following static system,
```math 
    y(t) = g(u(t), t) = \left[
        \begin{array}{l}
            t u_1(t) \\
            sin(u_1(t)) \\ 
            cos(u_2(t))
        \end{array}
        \right]
```
Note that the number of inputs is 2 and the number of outputs of is 3. To define such a system, the output function is written as
```@repl static_system_ex
using Jusdl # hide
g(u, t) = [t * u[1], sin(u[1]), cos(u[2])]
```
Note that the function `g` is defined in such a way that the input value `u` is sampled, which implies `u` is not a vector of function but is a vector of real. Having defined output function `outputfunc`, the system can be constructed. 
```@repl static_system_ex
ss = StaticSystem(readout=g, input=Inport(2), output=Outport(3))
```
Note the construction of input bus `Inport(2)` and output bus `Outport(3)` by recalling that the number of input is 2 and the number of output is 3.

A [`StaticSystem`](@ref) evolves by being triggered through its `trigger` pin. When triggered from its `trigger` pin, a `StaticSystem` reads the current time `t` from its `trigger` pin and computes its output `y` according to its output function `outputfunc` and writes its output `y(t)` to its `output` port (if `output` port exists since `output` port may be nothing depending on the relation defined by `outputfunc`). When constructed, a `StaticSystem` is not ready to be triggered since its `trigger` pin is not writeable. To make `ss` drivable, we need to construct the ports and pins for input-output and signaling. 
```@repl static_system_ex 
oport, iport, trg, hnd = Outport(length(ss.input)), Inport(length(ss.output)), Outpin(), Inpin{Bool}()
connect!(oport, ss.input) 
connect!(ss.output, iport) 
connect!(trg, ss.trigger)
connect!(ss.handshake, hnd)
task = launch(ss)
taskout = @async while true 
    all(take!(iport) .=== NaN) && break 
    end
```
Now, `ss` is drivable from its `trg` pin. 
```@repl static_system_ex
ss.trigger.link
```
Now let us drive `ss`.
```@repl static_system_ex 
put!(trg, 1.)
```
As this point `ss` wait for its to be written. Let us write some data to `oport`.
```@repl static_system_ex 
put!(oport, [10., 10.])
```
`ss` read the value `u` of its `input`(since `ss.input` is connected to `oport`), read the current time `t`, and computed its output value `y` and wrote it its `output` port. To signal that it succeeded to be take the step, it put a `true` to its handshake which needs to be taken.
```@repl static_system_ex 
hnd.link
take!(hnd)
```
We can see the current data in the `output` of `ss` through `iport` (since `iport` is connected to `ss.output`)
```@repl static_system_ex 
iport[1].link.buffer
```
Let us further drive `ss`.
```@repl static_system_ex 
for t in 2. : 10.
    put!(trg, t)
    put!(oport, [10 * t, 20 * t])
    take!(hnd)
end
```
The data written to the `output` of `ss` is also written to the internal buffers of `output`.
```@repl static_system_ex 
iport[1].link.buffer
```
In addition to the generic [`StaticSystem`](@ref),  `Jusdl` provides some well-known static systems given in the next section.

## Full API 
```@docs
@def_static_system 
StaticSystem 
Adder 
Multiplier 
Gain 
Terminator 
Memory 
Coupler 
Differentiator 
```