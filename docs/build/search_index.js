var documenterSearchIndex = {"docs":
[{"location":"manual/components/systems/dynamicsystems/rodesystem/#RODESystem-1","page":"RODESystem","title":"RODESystem","text":"","category":"section"},{"location":"manual/components/systems/dynamicsystems/rodesystem/#Construction-of-RODESystem-1","page":"RODESystem","title":"Construction of RODESystem","text":"","category":"section"},{"location":"manual/components/systems/dynamicsystems/rodesystem/#","page":"RODESystem","title":"RODESystem","text":"A RODESystem is represented by the state function ","category":"page"},{"location":"manual/components/systems/dynamicsystems/rodesystem/#","page":"RODESystem","title":"RODESystem","text":"beginarrayl\n    dx = f(x u t W)\nendarray","category":"page"},{"location":"manual/components/systems/dynamicsystems/rodesystem/#","page":"RODESystem","title":"RODESystem","text":"and the output function ","category":"page"},{"location":"manual/components/systems/dynamicsystems/rodesystem/#","page":"RODESystem","title":"RODESystem","text":"    y = g(x u t)","category":"page"},{"location":"manual/components/systems/dynamicsystems/rodesystem/#","page":"RODESystem","title":"RODESystem","text":"where t is the time, x in R^n is the state, u in R^p and y in R^m is output of the system. Therefore to construct a RODESystem, we need to define statefunc and outputfunc with the corresponding syntax,","category":"page"},{"location":"manual/components/systems/dynamicsystems/rodesystem/#","page":"RODESystem","title":"RODESystem","text":"function statefunc(dx, x, u, t)\n    dx .= ... # Update dx \nend","category":"page"},{"location":"manual/components/systems/dynamicsystems/rodesystem/#","page":"RODESystem","title":"RODESystem","text":"and ","category":"page"},{"location":"manual/components/systems/dynamicsystems/rodesystem/#","page":"RODESystem","title":"RODESystem","text":"function outputfunc(x, u, t)\n    y = ... # Compute y\n    return y\nend","category":"page"},{"location":"manual/components/systems/dynamicsystems/rodesystem/#","page":"RODESystem","title":"RODESystem","text":"As an example, consider the system with the state function","category":"page"},{"location":"manual/components/systems/dynamicsystems/rodesystem/#","page":"RODESystem","title":"RODESystem","text":"    beginarrayl\n        dx_1 = 2 x_1 sin(W_1 - W_2) \n        dx_2 = -2 x_2 cos(W_1 + W_2)\n    endarray","category":"page"},{"location":"manual/components/systems/dynamicsystems/rodesystem/#","page":"RODESystem","title":"RODESystem","text":"and with the output function ","category":"page"},{"location":"manual/components/systems/dynamicsystems/rodesystem/#","page":"RODESystem","title":"RODESystem","text":"    y = x","category":"page"},{"location":"manual/components/systems/dynamicsystems/rodesystem/#","page":"RODESystem","title":"RODESystem","text":"That is, all the state variable are taken as output. The statefunc and the outputfunc is defined as,","category":"page"},{"location":"manual/components/systems/dynamicsystems/rodesystem/#","page":"RODESystem","title":"RODESystem","text":"using Jusdl # hide\nfunction statefunc(dx, x, u, t, W)\n    dx[1] = 2x[1]*sin(W[1] - W[2])\n    dx[2] = -2x[2]*cos(W[1] + W[2])\nend\noutputfunc(x, u, t) = x","category":"page"},{"location":"manual/components/systems/dynamicsystems/rodesystem/#","page":"RODESystem","title":"RODESystem","text":"To construct the RODESystem, we need to specify the initial condition and time.","category":"page"},{"location":"manual/components/systems/dynamicsystems/rodesystem/#","page":"RODESystem","title":"RODESystem","text":"x0 = [1., 1.]\nt = 0.","category":"page"},{"location":"manual/components/systems/dynamicsystems/rodesystem/#","page":"RODESystem","title":"RODESystem","text":"Note from statefunc, the system has not any input, i.e. input is nothing, and has an output with a dimension of 1.","category":"page"},{"location":"manual/components/systems/dynamicsystems/rodesystem/#","page":"RODESystem","title":"RODESystem","text":"input = nothing\noutput = Bus(2)","category":"page"},{"location":"manual/components/systems/dynamicsystems/rodesystem/#","page":"RODESystem","title":"RODESystem","text":"We are ready to construct the system","category":"page"},{"location":"manual/components/systems/dynamicsystems/rodesystem/#","page":"RODESystem","title":"RODESystem","text":"ds = RODESystem(input, output, statefunc, outputfunc, x0, t)","category":"page"},{"location":"manual/components/systems/dynamicsystems/rodesystem/#","page":"RODESystem","title":"RODESystem","text":"Note that ds has a solver to solve its state function statefunc which is random differential equation. To solve its statefunc, the step size of the solver must be specified. See Random Differential Equtions of DifferentialEquations package.","category":"page"},{"location":"manual/components/systems/dynamicsystems/rodesystem/#","page":"RODESystem","title":"RODESystem","text":"ds.solver.params[:dt] = 1 / 100","category":"page"},{"location":"manual/components/systems/dynamicsystems/rodesystem/#Basic-Operation-of-RODESystem-1","page":"RODESystem","title":"Basic Operation of RODESystem","text":"","category":"section"},{"location":"manual/components/systems/dynamicsystems/rodesystem/#","page":"RODESystem","title":"RODESystem","text":"When a RODESystem is triggered from its trigger link, it read the current time from its trigger link, reads its input (if available, i.e. its input is not nothing), solves its state function, computes its output value and writes its output value its output bus (again, if available, i.e., its output bus is not nothing). To drive a RODESystem, it must be launched. Let us continue with ds constructed in the previous section.","category":"page"},{"location":"manual/components/systems/dynamicsystems/rodesystem/#","page":"RODESystem","title":"RODESystem","text":"task = launch(ds)","category":"page"},{"location":"manual/components/systems/dynamicsystems/rodesystem/#","page":"RODESystem","title":"RODESystem","text":"When launched, ds is ready to be driven. We can drive ds by drive(ds, t) or put!(ds.trigger, t) where t is the time until which we will drive ds. ","category":"page"},{"location":"manual/components/systems/dynamicsystems/rodesystem/#","page":"RODESystem","title":"RODESystem","text":"drive(ds, 1.)","category":"page"},{"location":"manual/components/systems/dynamicsystems/rodesystem/#","page":"RODESystem","title":"RODESystem","text":"When triggered, ds read the time t from its trigger link, solved its differential equation, computed its value and writes its output value to its output bus. To signal that, the evolution is succeeded, ds writes true to its handshake link which must be taken to further drive ds. (approve(ds)) can also be used. ","category":"page"},{"location":"manual/components/systems/dynamicsystems/rodesystem/#","page":"RODESystem","title":"RODESystem","text":"take!(ds.handshake)","category":"page"},{"location":"manual/components/systems/dynamicsystems/rodesystem/#","page":"RODESystem","title":"RODESystem","text":"We can continue to drive ds.","category":"page"},{"location":"manual/components/systems/dynamicsystems/rodesystem/#","page":"RODESystem","title":"RODESystem","text":"for t in 2. : 10.\n    put!(ds.trigger, t)\n    take!(ds.handshake)\nend","category":"page"},{"location":"manual/components/systems/dynamicsystems/rodesystem/#","page":"RODESystem","title":"RODESystem","text":"After each evolution, ds writes its current output value to its output bus. ","category":"page"},{"location":"manual/components/systems/dynamicsystems/rodesystem/#","page":"RODESystem","title":"RODESystem","text":"[ds.output[1].buffer.data ds.output[2].buffer.data]","category":"page"},{"location":"manual/components/systems/dynamicsystems/rodesystem/#","page":"RODESystem","title":"RODESystem","text":"When launched, a task was constructed which still running. As long as no exception is thrown during the evolution of ds, the state of task is running which implies ds can be driven. ","category":"page"},{"location":"manual/components/systems/dynamicsystems/rodesystem/#","page":"RODESystem","title":"RODESystem","text":"task","category":"page"},{"location":"manual/components/systems/dynamicsystems/rodesystem/#","page":"RODESystem","title":"RODESystem","text":"To terminate the task safely, ds should be terminated safely. ","category":"page"},{"location":"manual/components/systems/dynamicsystems/rodesystem/#","page":"RODESystem","title":"RODESystem","text":"terminate(ds)","category":"page"},{"location":"manual/components/systems/dynamicsystems/rodesystem/#","page":"RODESystem","title":"RODESystem","text":"Note that the state of task is done which implies the task has been terminated safely.","category":"page"},{"location":"manual/components/systems/dynamicsystems/rodesystem/#","page":"RODESystem","title":"RODESystem","text":"task","category":"page"},{"location":"manual/components/systems/dynamicsystems/rodesystem/#Full-API-1","page":"RODESystem","title":"Full API","text":"","category":"section"},{"location":"manual/components/systems/dynamicsystems/rodesystem/#","page":"RODESystem","title":"RODESystem","text":"RODESystem ","category":"page"},{"location":"manual/components/systems/dynamicsystems/rodesystem/#Jusdl.Components.Systems.DynamicSystems.RODESystem","page":"RODESystem","title":"Jusdl.Components.Systems.DynamicSystems.RODESystem","text":"RODESystem(input, output, statefunc, outputfunc, state, t, noise, solver=RODESolver)\n\nConstructs a RODESystem with input and output. statefunc is the state function and outputfunc is the output function.  The RODESystem is represented by the equations,\n\n    beginarrayl\n        dx = f(x u t W)dt 025\n        y = g(x u t)\n    endarray\n\nwhere x is the state, u is the value of input, y the value of output, ant t is the time t. f is the statefunc and g is the outputfunc. W is the Wiene process. noise is the noise of the system and solver is used to solve the above differential equation.\n\nThe signature of statefunc must be of the form \n\nfunction statefunc(dx, x, u, t, W)\n    dx .= ... # Update dx \nend\n\nand the signature of outputfunc must be of the form \n\nfunction outputfunc(x, u, t)\n    y = ... # Compute y\n    return y\nend\n\nExample\n\njulia> function statefunc(dx, x, u, t, W)\n         dx[1] = 2x[1]*sin(W[1] - W[2])\n         dx[2] = -2x[2]*cos(W[1] + W[2])\n       end\nstatefunc (generic function with 1 method)\n\njulia> outputfunc(x, u, t) = x\noutputfunc (generic function with 1 method)\n\njulia> ds = RODESystem(nothing, Bus(2), statefunc, outputfunc, [1., 1.], 0.)\n┌ Warning: `solver` must have `:dt` initialized in its `params` for the systems to evolve.\n└ @ Jusdl.Components.Systems.DynamicSystems ~/.julia/dev/Jusdl/src/components/systems/dynamic_systems/rode_systems.jl:55\nRODESystem(state:[1.0, 1.0], t:0.0, input:nothing, output:Bus(nlinks:2, eltype:Link{Float64}, isreadable:false, iswritable:false), noise:Noise(process:t: [0\n.0]\nu: Array{Float64,1}[[0.0, 0.0]], prototype:nothing, seed:0))\n\n\n\n\n\n","category":"type"},{"location":"modeling_and_simulation/modeling/#Modelling-1","page":"Modelling","title":"Modelling","text":"","category":"section"},{"location":"modeling_and_simulation/modeling/#","page":"Modelling","title":"Modelling","text":"Jusdl adopts signal-flow approach in modelling systems. Briefly, in signal-flow approach models consists of components and connections. Simulation of the models is performed in a clocked simulation environment. That is, the models are simulated in one shot by solving huge mathematical equation, but are simulated by evolving components individually and in parallel in different sampling intervals.","category":"page"},{"location":"modeling_and_simulation/modeling/#","page":"Modelling","title":"Modelling","text":"There exist different approaches in modeling of systems such as process-based, physical- interaction and signal-flow. Signal flow approach is the one that is used in JuSDL. In this approach, a model comprises of components and busses. Links connect the components to each other. The components are data processing units and it is the behavior of the component that determines how the data is processed. The component behavior is defined by the mathematical equations obtained as a result of the physical laws that the physical quantities used in the modeling of the component must comply. Depending upon the nature of the system and the modeling, these equations may change, i.e. they may or may not contain derivative terms, or they may contain the continuous time or discrete time variable, etc. The components interact themselves through their input-output busses. The data-flow through the busses is unidirectional, i.e., a component is driven by other components that write data to its input bus.","category":"page"},{"location":"modeling_and_simulation/modeling/#","page":"Modelling","title":"Modelling","text":"Model simulation is performed by evolving the components individually. To make the components have a common time base, a common time reference is used. The time reference generates pulses at simulation sampling intervals and writes these pulses to the trigger links of the components to trigger them. Each component that is triggered read its input data from its input bus, calculates its output according to its output model and writes it to its output bus.","category":"page"},{"location":"modeling_and_simulation/modeling/#","page":"Modelling","title":"Modelling","text":"<center>\n    <img src=\"../assets/Model/model.png\" alt=\"model\" width=\"50%\"/>\n</center>","category":"page"},{"location":"modeling_and_simulation/modeling/#Components-1","page":"Modelling","title":"Components","text":"","category":"section"},{"location":"modeling_and_simulation/modeling/#","page":"Modelling","title":"Modelling","text":"The component types in JuSDL are shown in Figure 2.2 together with output and state equations. The components can be grouped as sources, sinks, and systems. The sources are components that generate signals as functions of time. Having been triggered, a source computes its output according to its output function and writes it to its output bus. The sources do not have input busses as their outputs depend only on time. The sinks are data processing units. Their primary objectives are to process the data flowing through the busses of the model online. Having been triggered, a sink reads its input data and process them, i.e. data can be visualized by being plotted on the graphical user interface, can be observed by being printed on the console, can be stored on data files. The data processing capability of the sinks can be enriched by integrating new plugins that can be developed using the standard Julia library or various available Julia packages. For example, invariants, spectral properties or statistical information can be derived from the data, parameter estimation can be performed or various signal processing techniques can be applied on the data. JuSDL has been designed to be flexible enough to allow one to enlarge the scope of its available plugins by integrating newly-defined ones.","category":"page"},{"location":"modeling_and_simulation/modeling/#","page":"Modelling","title":"Modelling","text":"<center>\n    <img src=\"../assets/Components/components.png\" alt=\"model\" width=\"100%\"/>\n</center>","category":"page"},{"location":"modeling_and_simulation/modeling/#","page":"Modelling","title":"Modelling","text":"As the output of a static system depends on input and time, a static system is defined by an output equation. Having been triggered, a static system reads its input data, calculates its output according to its output function and writes it to its output bus. In dynamic systems, however, system behavior is characterized by states and output of a dynamic system depends on input, previous state and time. Therefore, a dynamic system is defined by a state equation and an output equation. When triggered, a dynamic system reads its input, update its state according to its state equation, calculates its output according to its output equation and writes its output to its output bus. JuSDL is capable of simulating the dynamic systems with state equations in the form of the ordinary differential equation(ODE), differential algebraic equation(DAE), random ordinary differential equation(RODE), stochastic differential equation(SDE), delay differential equation(DDE) or discrete difference equation. Most of the available simulation environments allow the simulation of systems represented by ordinary differential equations or differential algebraic equations. Therefore, analyzes such as noise analysis, delay analysis or random change of system parameters cannot be performed in these simulation environments. On the contrary, JuSDL makes it possible for all these analyses to be performed owing to its ability to solve such a wide range of state equations.","category":"page"},{"location":"modeling_and_simulation/modeling/#Busses-1","page":"Modelling","title":"Busses","text":"","category":"section"},{"location":"modeling_and_simulation/modeling/#","page":"Modelling","title":"Modelling","text":"Busses consist of bunches of links. Links are built upon channels that are defined in standard Julia library. The data written to(read from) the busses is written to(read from) the links which are then written to(read from) the channels. Active Julia tasks that are bound to channels must exist for data to flow over these channels. Ju- lia tasks are control flow features that allow calculations to be flexibly suspended and maintained without directly communicating the task scheduler of the operating system. Communication and data exchange between the tasks are carried out through Julia channels to which they are bound. ","category":"page"},{"location":"modeling_and_simulation/modeling/#","page":"Modelling","title":"Modelling","text":"<head>\n    <style>\n    * {\n    box-sizing: border-box;\n    }\n\n    .column {\n    float: left;\n    width: 33.33%;\n    padding: 5px;\n    }\n\n    /* Clearfix (clear floats) */\n    .row::after {\n    content: \"\";\n    clear: both;\n    display: table;\n    }\n\n    /* Responsive layout - makes the three columns stack on top of each other instead of next to each other */\n    @media screen and (max-width: 500px) {\n    .column {\n        width: 100%;\n    }\n    }\n    </style>\n</head>\n\n<body>\n    <div class=\"row\">\n        <div class=\"column\">\n            <img src=\"../assets/Tasks/reader_task.png\" alt=\"reader_task\" style=\"width:60%\">\n        </div>\n        <div class=\"column\">\n            <img src=\"../assets/Tasks/writer_task.png\" alt=\"writer_task\" style=\"width:60%\">\n        </div>\n        <div class=\"column\">\n            <img src=\"../assets/Tasks/reader_writer_task.png\" alt=\"reader_writer_task\" style=\"width:100%\">\n        </div>\n    </div>\n</body>","category":"page"},{"location":"modeling_and_simulation/modeling/#","page":"Modelling","title":"Modelling","text":"In the figure above are shown symbolically the tasks that must be bound to the channel to make a channel readable, writable and both readable and writable. The putter and the taker task is the task that writes data to and reads data from the channel, respectively. To be able to read data from one side of the channel, an active putter task must be bound to the chan- nel at the other side of the channel, and the channel is called a readable channel. Similarly, to be able to write data to one side of the channel, an active taker task must be bound to the channel at the other side, and the channel is called a writable channel. If both active putter and taker tasks are bound to either side of the channel, then the data can both be read from and written to the channel, and the channel is called a both readable and writable channel. The data-flow through the channel is only achieved if the channel is both readable and writable channel. The data read from a readable channel is the data written to the channel by the putter task of the channel. If data has not been written yet to the channel by the putter task of the channel during a reading process, then reading does not occur and the putter task is waited to put data to the channel. Similarly, if the data on the channel has not been read yet from the channel by the taker task during a writing process, then the taker task is waited to take data from the channel. In the modeling approach adopted, the components reading data from a bus are driven by other components writing data to the bus. Therefore, all of the busses of the model must be both readable and writable busses so that data can flow the busses. This means that all the busses of the model must be connected to a component from both ends. Otherwise, the simulation gets stuck and does not end during a reading process from a channel that is not connected to a component. During the simulation, the busses can be arranged as desired, the gain of the busses can be changed, new busses can be added or an existing bus can be broken. In other words, the structure of the system being simulated can change dynamically. This allows one to perform topological studies such as the investigation of the effects of change in the topology of a network or the change o coupling strengths on the behavior of the network.","category":"page"},{"location":"manual/components/systems/dynamicsystems/odesystem/#ODESystem-1","page":"ODESystem","title":"ODESystem","text":"","category":"section"},{"location":"manual/components/systems/dynamicsystems/odesystem/#Basic-Operation-of-ODESystem-1","page":"ODESystem","title":"Basic Operation of ODESystem","text":"","category":"section"},{"location":"manual/components/systems/dynamicsystems/odesystem/#","page":"ODESystem","title":"ODESystem","text":"When an ODESystem is triggered, it reads its current time from its trigger link, reads its input, solves its differential equation and computes its output. Let us observe the basic operation of ODESystems with a simple example. ","category":"page"},{"location":"manual/components/systems/dynamicsystems/odesystem/#","page":"ODESystem","title":"ODESystem","text":"We first construct an ODESystem. Since an ODESystem is represented by its state equation and output equation, we need to define those equations.","category":"page"},{"location":"manual/components/systems/dynamicsystems/odesystem/#","page":"ODESystem","title":"ODESystem","text":"using Jusdl # hide \nsfunc(dx,x,u,t) = (dx .= -0.5x)\nofunc(x, u, t) = x","category":"page"},{"location":"manual/components/systems/dynamicsystems/odesystem/#","page":"ODESystem","title":"ODESystem","text":"Let us construct the system ","category":"page"},{"location":"manual/components/systems/dynamicsystems/odesystem/#","page":"ODESystem","title":"ODESystem","text":"ds = ODESystem(Bus(1), Bus(1), sfunc, ofunc, [1.], 0.)","category":"page"},{"location":"manual/components/systems/dynamicsystems/odesystem/#","page":"ODESystem","title":"ODESystem","text":"Note that ds is a single input single output ODESystem with an initial state of [1.] and initial time 0.. To drive, i.e. trigger ds, we need to launch it.","category":"page"},{"location":"manual/components/systems/dynamicsystems/odesystem/#","page":"ODESystem","title":"ODESystem","text":"task = launch(ds)","category":"page"},{"location":"manual/components/systems/dynamicsystems/odesystem/#","page":"ODESystem","title":"ODESystem","text":"When launced, ds is ready to driven. ds is driven from its trigger link. Note that the trigger link of ds is writable. ","category":"page"},{"location":"manual/components/systems/dynamicsystems/odesystem/#","page":"ODESystem","title":"ODESystem","text":"ds.trigger","category":"page"},{"location":"manual/components/systems/dynamicsystems/odesystem/#","page":"ODESystem","title":"ODESystem","text":"Let us drive ds to the time of t of 1 second.","category":"page"},{"location":"manual/components/systems/dynamicsystems/odesystem/#","page":"ODESystem","title":"ODESystem","text":"drive(ds, 1.)","category":"page"},{"location":"manual/components/systems/dynamicsystems/odesystem/#","page":"ODESystem","title":"ODESystem","text":"When driven, ds reads current time of t from its trigger link, reads its input value from its input, solves its differential equation and computes its output values and writes its output. So, for the step to be continued, an input values must be written. Note that the input of ds is writable,","category":"page"},{"location":"manual/components/systems/dynamicsystems/odesystem/#","page":"ODESystem","title":"ODESystem","text":"ds.input","category":"page"},{"location":"manual/components/systems/dynamicsystems/odesystem/#","page":"ODESystem","title":"ODESystem","text":"Let us write some value. ","category":"page"},{"location":"manual/components/systems/dynamicsystems/odesystem/#","page":"ODESystem","title":"ODESystem","text":"put!(ds.input, [5.])","category":"page"},{"location":"manual/components/systems/dynamicsystems/odesystem/#","page":"ODESystem","title":"ODESystem","text":"At this point, ds completed its step and put true to its handshake link to signal that its step is succeeded.","category":"page"},{"location":"manual/components/systems/dynamicsystems/odesystem/#","page":"ODESystem","title":"ODESystem","text":"ds.handshake","category":"page"},{"location":"manual/components/systems/dynamicsystems/odesystem/#","page":"ODESystem","title":"ODESystem","text":"To complete the step and be ready for another step, we need to approve the step by reading its handshake. ","category":"page"},{"location":"manual/components/systems/dynamicsystems/odesystem/#","page":"ODESystem","title":"ODESystem","text":"take!(ds.handshake)","category":"page"},{"location":"manual/components/systems/dynamicsystems/odesystem/#","page":"ODESystem","title":"ODESystem","text":"At this point, ds can be driven further. ","category":"page"},{"location":"manual/components/systems/dynamicsystems/odesystem/#","page":"ODESystem","title":"ODESystem","text":"for t in 2. : 10.\n    put!(ds.trigger, t)\n    put!(ds.input, [t * 10])\n    take!(ds.handshake)\nend","category":"page"},{"location":"manual/components/systems/dynamicsystems/odesystem/#","page":"ODESystem","title":"ODESystem","text":"Note that all the output value of ds is written to its outputbus,","category":"page"},{"location":"manual/components/systems/dynamicsystems/odesystem/#","page":"ODESystem","title":"ODESystem","text":"ds.output[1].buffer.data","category":"page"},{"location":"manual/components/systems/dynamicsystems/odesystem/#","page":"ODESystem","title":"ODESystem","text":"When we launched ds, we constructed a task and the task is still running.","category":"page"},{"location":"manual/components/systems/dynamicsystems/odesystem/#","page":"ODESystem","title":"ODESystem","text":"task","category":"page"},{"location":"manual/components/systems/dynamicsystems/odesystem/#","page":"ODESystem","title":"ODESystem","text":"To terminate the task safely, we need to terminate ds safely.","category":"page"},{"location":"manual/components/systems/dynamicsystems/odesystem/#","page":"ODESystem","title":"ODESystem","text":"terminate(ds)","category":"page"},{"location":"manual/components/systems/dynamicsystems/odesystem/#","page":"ODESystem","title":"ODESystem","text":"Now, the state of the task is done. ","category":"page"},{"location":"manual/components/systems/dynamicsystems/odesystem/#","page":"ODESystem","title":"ODESystem","text":"task","category":"page"},{"location":"manual/components/systems/dynamicsystems/odesystem/#","page":"ODESystem","title":"ODESystem","text":"So, it is not possible to drive ds.","category":"page"},{"location":"manual/components/systems/dynamicsystems/odesystem/#Mutation-in-State-Function-in-ODESystem-1","page":"ODESystem","title":"Mutation in State Function in ODESystem","text":"","category":"section"},{"location":"manual/components/systems/dynamicsystems/odesystem/#","page":"ODESystem","title":"ODESystem","text":"Consider a system with the following ODE","category":"page"},{"location":"manual/components/systems/dynamicsystems/odesystem/#","page":"ODESystem","title":"ODESystem","text":"beginarrayl\n    dotx = f(x u t) \n    y = g(x u t) \nendarray","category":"page"},{"location":"manual/components/systems/dynamicsystems/odesystem/#","page":"ODESystem","title":"ODESystem","text":"where x in R^d y in R^m u in R^p. To construct and ODESystem,  The signature of the state function statefunc must be of the form ","category":"page"},{"location":"manual/components/systems/dynamicsystems/odesystem/#","page":"ODESystem","title":"ODESystem","text":"function statefunc(dx, x, u, t)\n    dx .= ... # Update dx\nend","category":"page"},{"location":"manual/components/systems/dynamicsystems/odesystem/#","page":"ODESystem","title":"ODESystem","text":"Note that statefunc does not construct dx but updates dx and does not return anything.  This is for performance reasons. On the contrary, the signature of the output function outputfunc must be of the form,","category":"page"},{"location":"manual/components/systems/dynamicsystems/odesystem/#","page":"ODESystem","title":"ODESystem","text":"function outputfunc(x, u, t)\n    y = ... # Compute y\n    return y\nend","category":"page"},{"location":"manual/components/systems/dynamicsystems/odesystem/#","page":"ODESystem","title":"ODESystem","text":"Note the output value y is computed and returned from outputfunc. y is not updated but generated in the outputfunc.","category":"page"},{"location":"manual/components/systems/dynamicsystems/odesystem/#Full-API-1","page":"ODESystem","title":"Full API","text":"","category":"section"},{"location":"manual/components/systems/dynamicsystems/odesystem/#","page":"ODESystem","title":"ODESystem","text":"ODESystem \nLinearSystem \nLorenzSystem \nChenSystem\nChuaSystem\nRosslerSystem \nVanderpolSystem","category":"page"},{"location":"manual/components/systems/dynamicsystems/odesystem/#Jusdl.Components.Systems.DynamicSystems.ODESystem","page":"ODESystem","title":"Jusdl.Components.Systems.DynamicSystems.ODESystem","text":"ODESystem(input, output, statefunc, outputfunc, state, t,; solver=ODESolver)\n\nConstructs an ODESystem with input and output. statefunc is the state function and outputfunc is the output function. ODESystem is represented by the equations.\n\n    beginarrayl\n        dotx = f(x u t) 025cm\n        y = g(x u t)\n    endarray\n\nwhere t is the time t, x is state, u is the value of input, y is the value of output. f is statefunc and g is outputfunc. solver is used to solve the above differential equation.\n\nThe signature of statefunc must be of the form,\n\nfunction statefunc(dx, x, u, t)\n    dx .= ... # Update dx \nend\n\nand the signature of outputfunc must be of the form,\n\nfunction outputfunc(x, u, t)\n    y = ... # Compute y\n    return y\nend\n\nExample\n\njulia> sfunc(dx,x,u,t) = (dx .= 0.5x)\nsfunc (generic function with 1 method)\n\njulia> ofunc(x, u, t) = x\nofunc (generic function with 1 method)\n\njulia> ds = ODESystem(Bus(1), Bus(1), sfunc, ofunc, [1.], 0.)\nODESystem(state:[1.0], t:0.0, input:Bus(nlinks:1, eltype:Link{Float64}, isreadable:false, iswritable:false), output:Bus(nlinks:1, eltype:Link{Float64}, isreadable:false, iswritable:false))\n\n\n\n\n\n","category":"type"},{"location":"manual/components/systems/dynamicsystems/odesystem/#Jusdl.Components.Systems.DynamicSystems.LinearSystem","page":"ODESystem","title":"Jusdl.Components.Systems.DynamicSystems.LinearSystem","text":"LinearSystem(input, output; A=fill(-1, 1, 1), B=fill(0, 1, 1), C=fill(1, 1, 1), D=fill(0, 1, 1), \n    state=rand(size(A,1)), t=0., solver=ODESolver)\n\nConstructs a LinearSystem with input and output. The LinearSystem is represented by the following state and output equations.\n\nbeginarrayl\n    dotx = A x + B u 025cm\n    y = C x + D u \nendarray\n\nwhere x is state. solver is used to solve the above differential equation.\n\n\n\n\n\n","category":"type"},{"location":"manual/components/systems/dynamicsystems/odesystem/#Jusdl.Components.Systems.DynamicSystems.LorenzSystem","page":"ODESystem","title":"Jusdl.Components.Systems.DynamicSystems.LorenzSystem","text":"LorenzSystem(input, output; sigma=10, beta=8/3, rho=28, gamma=1, outputfunc=allstates, state=rand(3), t=0.,\n    solver=ODESolver, cplmat=diagm([1., 1., 1.]))\n\nConstructs a LorenzSystem with input and output. sigma, beta, rho and gamma is the system parameters. If input is nothing, the state equation of LorenzSystem is \n\nbeginarrayl\n    dotx_1 = gamma (sigma (x_2 - x_1)) 025cm\n    dotx_2 = gamma (x_1 (rho - x_3) - x_2) 025cm\n    dotx_3 = gamma (x_1 x_2 - beta x_3) \nendarray\n\nwhere x is state. solver is used to solve the above differential equation. If input is not nothing, then the state eqaution is\n\nbeginarrayl\n    dotx_1 = gamma (sigma (x_2 - x_1)) + sum_j = 1^3 alpha_1j u_j 025cm\n    dotx_2 = gamma (x_1 (rho - x_3) - x_2) + sum_j = 1^3 alpha_2j u_j 025cm\n    dotx_3 = gamma (x_1 x_2 - beta x_3) + sum_j = 1^3 alpha_3j u_j \nendarray\n\nwhere A = alpha_ij is cplmat and u = u_j is the value of the input. The output function is \n\n    y = g(x u t)\n\nwhere t is time t, y is the value of the output and g is outputfunc.\n\n\n\n\n\n","category":"type"},{"location":"manual/components/systems/dynamicsystems/odesystem/#Jusdl.Components.Systems.DynamicSystems.ChenSystem","page":"ODESystem","title":"Jusdl.Components.Systems.DynamicSystems.ChenSystem","text":"ChenSystem(input, output; a=35, b=3, c=28, gamma=1, outputfunc=allstates, state=rand(3), t=0.,\n    solver=ODESolver, cplmat=diagm([1., 1., 1.]))\n\nConstructs a ChenSystem with input and output. a, b, c and gamma is the system parameters. If input is nothing, the state equation of LorenzSystem is \n\nbeginarrayl\n    dotx_1 = gamma (a (x_2 - x_1)) 025cm\n    dotx_2 = gamma ((c - a) x_1 + c x_2 + x_1 x_3) 025cm\n    dotx_3 = gamma (x_1 x_2 - b x_3) \nendarray\n\nwhere x is state. solver is used to solve the above differential equation. If input is not nothing, then the state eqaution is\n\nbeginarrayl\n    dotx_1 = gamma (a (x_2 - x_1)) + sum_j = 1^3 alpha_1j u_j 025cm\n    dotx_2 = gamma ((c - a) x_1 + c x_2 + x_1 x_3) + sum_j = 1^3 alpha_2j u_j 025cm\n    dotx_3 = gamma (x_1 x_2 - b x_3) + sum_j = 1^3 alpha_3j u_j \nendarray\n\nwhere A = alpha_ij is cplmat and u = u_j is the value of the input. The output function is \n\n    y = g(x u t)\n\nwhere t is time t, y is the value of the output and g is outputfunc.\n\n\n\n\n\n","category":"type"},{"location":"manual/components/systems/dynamicsystems/odesystem/#Jusdl.Components.Systems.DynamicSystems.ChuaSystem","page":"ODESystem","title":"Jusdl.Components.Systems.DynamicSystems.ChuaSystem","text":"ChuaSystem(input, output; diode=PiecewiseLinearDiode(), alpha=15.6, beta=28., gamma=1., \n    outputfunc=allstates, state=rand(3), t=0., solver=ODESolver, cplmat=diagm([1., 1., 1.]))\n\nConstructs a ChuaSystem with input and output. diode, alpha, beta and gamma is the system parameters. If input is nothing, the state equation of LorenzSystem is \n\nbeginarrayl\n    dotx_1 = gamma (alpha (x_2 - x_1 - h(x_1))) 025cm\n    dotx_2 = gamma (x_1 - x_2 + x_3 ) 025cm\n    dotx_3 = gamma (-beta x_2) \nendarray\n\nwhere x is state. solver is used to solve the above differential equation. If input is not nothing, then the state eqaution is\n\nbeginarrayl\n    dotx_1 = gamma (alpha (x_2 - x_1 - h(x_1))) + sum_j = 1^3 theta_1j u_j 025cm\n    dotx_2 = gamma (x_1 - x_2 + x_3 ) + sum_j = 1^3 theta_2j u_j 025cm\n    dotx_3 = gamma (-beta x_2) + sum_j = 1^3 theta_3j u_j \nendarray\n\nwhere Theta = theta_ij is cplmat and u = u_j is the value of the input. The output function is \n\n    y = g(x u t)\n\nwhere t is time t, y is the value of the output and g is outputfunc.\n\n\n\n\n\n","category":"type"},{"location":"manual/components/systems/dynamicsystems/odesystem/#Jusdl.Components.Systems.DynamicSystems.RosslerSystem","page":"ODESystem","title":"Jusdl.Components.Systems.DynamicSystems.RosslerSystem","text":"RosslerSystem(input, output; a=0.38, b=0.3, c=4.82, gamma=1., outputfunc=allstates, state=rand(3), t=0., \n    solver=ODESolver, cplmat=diagm([1., 1., 1.]))\n\nConstructs a RosllerSystem with input and output. a, b, c and gamma is the system parameters. If input is nothing, the state equation of LorenzSystem is \n\nbeginarrayl\n    dotx_1 = gamma (-x_2 - x_3) 025cm\n    dotx_2 = gamma (x_1 + a x_2) 025cm\n    dotx_3 = gamma (b + x_3 (x_1 - c))\nendarray\n\nwhere x is state. solver is used to solve the above differential equation. If input is not nothing, then the state eqaution is\n\nbeginarrayl\n    dotx_1 = gamma (-x_2 - x_3) + sum_j = 1^3 theta_1j u_j 025cm\n    dotx_2 = gamma (x_1 + a x_2 ) + sum_j = 1^3 theta_2j u_j 025cm\n    dotx_3 = gamma (b + x_3 (x_1 - c)) + sum_j = 1^3 theta_3j u_j \nendarray\n\nwhere Theta = theta_ij is cplmat and u = u_j is the value of the input. The output function is \n\n    y = g(x u t)\n\nwhere t is time t, y is the value of the output and g is outputfunc.\n\n\n\n\n\n","category":"type"},{"location":"manual/components/systems/dynamicsystems/odesystem/#Jusdl.Components.Systems.DynamicSystems.VanderpolSystem","page":"ODESystem","title":"Jusdl.Components.Systems.DynamicSystems.VanderpolSystem","text":"VanderpolSystem(input, output; mu=5., gamma=1., outputfunc=allstates, state=rand(2), t=0., \n    solver=ODESolver, cplmat=diagm([1., 1]))\n\nConstructs a VanderpolSystem with input and output. mu and gamma is the system parameters. If input is nothing, the state equation of LorenzSystem is \n\nbeginarrayl\n    dotx_1 = gamma (x_2) 025cm\n    dotx_2 = gamma (mu (x_1^2 - 1) x_2 - x_1 )\nendarray\n\nwhere x is state. solver is used to solve the above differential equation. If input is not nothing, then the state eqaution is\n\nbeginarrayl\n    dotx_1 = gamma (x_2) + sum_j = 1^3 theta_1j u_j 025cm\n    dotx_2 = gamma (mu (x_1^2 - 1) x_2 - x_1) + sum_j = 1^3 theta_2j u_j \nendarray\n\nwhere Theta = theta_ij is cplmat and u = u_j is the value of the input. The output function is \n\n    y = g(x u t)\n\nwhere t is time t, y is the value of the output and g is outputfunc.\n\n\n\n\n\n","category":"type"},{"location":"manual/components/systems/dynamicsystems/ddesystem/#DDESystem-1","page":"DDESystem","title":"DDESystem","text":"","category":"section"},{"location":"manual/components/systems/dynamicsystems/ddesystem/#Construction-of-DDESystem-1","page":"DDESystem","title":"Construction of DDESystem","text":"","category":"section"},{"location":"manual/components/systems/dynamicsystems/ddesystem/#","page":"DDESystem","title":"DDESystem","text":"A DDESystem is represented by the following state equation","category":"page"},{"location":"manual/components/systems/dynamicsystems/ddesystem/#","page":"DDESystem","title":"DDESystem","text":"    dotx = f(x h u t) quad t geq t_0","category":"page"},{"location":"manual/components/systems/dynamicsystems/ddesystem/#","page":"DDESystem","title":"DDESystem","text":"where t is the time, x is the value of the state, u is the value of the input. h is the history function for which ","category":"page"},{"location":"manual/components/systems/dynamicsystems/ddesystem/#","page":"DDESystem","title":"DDESystem","text":"    x(t) = h(t) quad t leq t_0","category":"page"},{"location":"manual/components/systems/dynamicsystems/ddesystem/#","page":"DDESystem","title":"DDESystem","text":"and by the output equation","category":"page"},{"location":"manual/components/systems/dynamicsystems/ddesystem/#","page":"DDESystem","title":"DDESystem","text":"    y = g(x u t) ","category":"page"},{"location":"manual/components/systems/dynamicsystems/ddesystem/#","page":"DDESystem","title":"DDESystem","text":"where y is the value of the output. ","category":"page"},{"location":"manual/components/systems/dynamicsystems/ddesystem/#","page":"DDESystem","title":"DDESystem","text":"As an example, consider a system with the state equation ","category":"page"},{"location":"manual/components/systems/dynamicsystems/ddesystem/#","page":"DDESystem","title":"DDESystem","text":"    beginarrayl\n    dotx = -x(t - tau) quad t geq 0\n    x(t) = 1 -tau leq t leq 0\n    endarray","category":"page"},{"location":"manual/components/systems/dynamicsystems/ddesystem/#","page":"DDESystem","title":"DDESystem","text":"First, we define the history function histfunc,","category":"page"},{"location":"manual/components/systems/dynamicsystems/ddesystem/#","page":"DDESystem","title":"DDESystem","text":"using Jusdl # hdie \nconst out = zeros(1)\nhistfunc(out, u, t)","category":"page"},{"location":"manual/components/systems/dynamicsystems/ddesystem/#","page":"DDESystem","title":"DDESystem","text":"Note that histfunc mutates a vector out. This mutation is for performance reasons. Next the state function can be defined","category":"page"},{"location":"manual/components/systems/dynamicsystems/ddesystem/#","page":"DDESystem","title":"DDESystem","text":"function statefunc(dx, x, h, u, t)\n    h(out, u, t - tau) # Update out vector\n    dx[1] = out[1] + x[1]\nend","category":"page"},{"location":"manual/components/systems/dynamicsystems/ddesystem/#","page":"DDESystem","title":"DDESystem","text":"and let us take all the state variables as outputs. Thus, the output function is ","category":"page"},{"location":"manual/components/systems/dynamicsystems/ddesystem/#","page":"DDESystem","title":"DDESystem","text":"outputfunc(x, u, t) = x","category":"page"},{"location":"manual/components/systems/dynamicsystems/ddesystem/#","page":"DDESystem","title":"DDESystem","text":"Next, we need to define the history for the system. History is defined by specifying a history function, and the type of the lags. There may be two different lag: constant lags which are independent of the state variable x and the dependent lags which are mainly the functions of the state variable x. Note that for this example, the have constant lags. Thus, ","category":"page"},{"location":"manual/components/systems/dynamicsystems/ddesystem/#","page":"DDESystem","title":"DDESystem","text":"tau = 1\nconslags = [tau]\nhist = History(histfunc, conslags, ())","category":"page"},{"location":"manual/components/systems/dynamicsystems/ddesystem/#","page":"DDESystem","title":"DDESystem","text":"At this point, we are ready to construct the system. ","category":"page"},{"location":"manual/components/systems/dynamicsystems/ddesystem/#","page":"DDESystem","title":"DDESystem","text":"ds = DDESystem(nothing, Bus(), statefunc, outputfunc, state, hist, 0.)","category":"page"},{"location":"manual/components/systems/dynamicsystems/ddesystem/#Basic-Operation-of-DDESystem-1","page":"DDESystem","title":"Basic Operation of DDESystem","text":"","category":"section"},{"location":"manual/components/systems/dynamicsystems/ddesystem/#","page":"DDESystem","title":"DDESystem","text":"The basis operaiton of DDESystem is the same as those of other dynamical systems. When triggered from its trigger link, the DDESystem reads its time from its trigger link, reads input, solves its differential equation, computes its output and writes the computed output to its output bus. To drive DDESystem, we must first launch it,","category":"page"},{"location":"manual/components/systems/dynamicsystems/ddesystem/#","page":"DDESystem","title":"DDESystem","text":"task = launch(ds)","category":"page"},{"location":"manual/components/systems/dynamicsystems/ddesystem/#","page":"DDESystem","title":"DDESystem","text":"When launched, ds is drivable. To drive ds, we can use the syntax drive(ds, t) or put!(ds.trigger, t) where t is the time until which ds is to be driven.","category":"page"},{"location":"manual/components/systems/dynamicsystems/ddesystem/#","page":"DDESystem","title":"DDESystem","text":"drive(ds, 1.)","category":"page"},{"location":"manual/components/systems/dynamicsystems/ddesystem/#","page":"DDESystem","title":"DDESystem","text":"When driven, ds reads the time t from its trigger link, (since its input is nothing, ds does nothing during its input reading stage), solves its differential equation, computes output and writes the value of its output to its output bus. To signify, the step was taken with success, ds writes true to its handshake which must be read to further drive ds. For this, we can use the syntax approve(ds) or take!(ds.handshake).","category":"page"},{"location":"manual/components/systems/dynamicsystems/ddesystem/#","page":"DDESystem","title":"DDESystem","text":"approve(ds)","category":"page"},{"location":"manual/components/systems/dynamicsystems/ddesystem/#","page":"DDESystem","title":"DDESystem","text":"We can continue to drive ds. ","category":"page"},{"location":"manual/components/systems/dynamicsystems/ddesystem/#","page":"DDESystem","title":"DDESystem","text":"for t in 2. : 10.\n    drive(ds, t)\n    approve(ds)\nend","category":"page"},{"location":"manual/components/systems/dynamicsystems/ddesystem/#","page":"DDESystem","title":"DDESystem","text":"When launched, we constructed a task whose state is running which implies that ds can be driven. ","category":"page"},{"location":"manual/components/systems/dynamicsystems/ddesystem/#","page":"DDESystem","title":"DDESystem","text":"task","category":"page"},{"location":"manual/components/systems/dynamicsystems/ddesystem/#","page":"DDESystem","title":"DDESystem","text":"As long as the state of the task is running, ds can be driven. To terminate task safely, we need to terminate the ds. ","category":"page"},{"location":"manual/components/systems/dynamicsystems/ddesystem/#","page":"DDESystem","title":"DDESystem","text":"terminate(ds)","category":"page"},{"location":"manual/components/systems/dynamicsystems/ddesystem/#","page":"DDESystem","title":"DDESystem","text":"Note that the state of task is done which implies that ds is not drivable any more. ","category":"page"},{"location":"manual/components/systems/dynamicsystems/ddesystem/#","page":"DDESystem","title":"DDESystem","text":"Note that the output values of ds is written to its output bus. ","category":"page"},{"location":"manual/components/systems/dynamicsystems/ddesystem/#","page":"DDESystem","title":"DDESystem","text":"ds.output[1].buffer.data","category":"page"},{"location":"manual/components/systems/dynamicsystems/ddesystem/#Full-API-1","page":"DDESystem","title":"Full API","text":"","category":"section"},{"location":"manual/components/systems/dynamicsystems/ddesystem/#","page":"DDESystem","title":"DDESystem","text":"DDESystem","category":"page"},{"location":"manual/components/systems/dynamicsystems/ddesystem/#Jusdl.Components.Systems.DynamicSystems.DDESystem","page":"DDESystem","title":"Jusdl.Components.Systems.DynamicSystems.DDESystem","text":"DDESystem(input, output, statefunc, outputfunc, state, history, t; solver=DDESolver)\n\nConstructs a DDESystem with input and output. statefunc is the state function and outputfunc is the output function of DDESystem. The DDESystem is represented by\n\n    beginarrayl\n        dotx = f(x h u t) \n        y = g(x u t)\n    endarray\n\nwhere t is the time t, x is the value of state, u is the value of input, y is the value of output. f is statefunc, g is outputfunc. his the history function of history. solver is used to solve the above differential equation.\n\nThe syntax of statefunc must be of the form \n\nfunction statefunc(dx, x, u, t)\n    dx .= ... # Update dx\nend\n\nand the syntax of outputfunc must be of the form \n\nfunction outputfunc(x, u, t)\n    y = ... # Compute y \n    return y\nend\n\nExample\n\njulia> const out = zeros(1)\n1-element Array{Float64,1}:\n 0.0\n\njulia> histfunc(out, u, t) = (out .= 1.)\nhistfunc (generic function with 1 method)\n\njulia> function statefunc(dx, x, h, u, t)\n           h(out, u, t - tau) # Update out vector\n           dx[1] = out[1] + x[1]\n       end\nstatefunc (generic function with 1 method)\n\njulia> outputfunc(x, u, t) = x\noutputfunc (generic function with 1 method)\n\njulia> tau = 1\n1\n\njulia> conslags = [tau]\n1-element Array{Int64,1}:\n 1\n\njulia> hist = History(histfunc, conslags, ())\nHistory(func:histfunc, conslags:[1], seed:(), neutral:false\n\njulia> ds = DDESystem(nothing, Bus(), statefunc, outputfunc, [1.], hist, 0.)\nDDESystem(state:[1.0], history:History(func:histfunc, conslags:[1], seed:(), neutral:false, t:0.0, input:nothing, output:Bus(nlinks:1, eltype:Link{Float64}, isreadable:false, iswritable:false), history:History(func:histfunc, conslags:[1], seed:(), neutral:false)\n\n\n\n\n\n","category":"type"},{"location":"manual/components/sinks/printer/#Printer-1","page":"Printer","title":"Printer","text":"","category":"section"},{"location":"manual/components/sinks/printer/#Basic-Operation-of-Printers-1","page":"Printer","title":"Basic Operation of Printers","text":"","category":"section"},{"location":"manual/components/sinks/printer/#","page":"Printer","title":"Printer","text":"See Basic Operation of Writers since the operation of Writer and that of Printer is very similar.","category":"page"},{"location":"manual/components/sinks/printer/#Full-API-1","page":"Printer","title":"Full API","text":"","category":"section"},{"location":"manual/components/sinks/printer/#","page":"Printer","title":"Printer","text":"Printer\nprint(printer::Printer, td, xd)\nopen(printer::Printer) \nclose(printer::Printer)","category":"page"},{"location":"manual/components/sinks/printer/#Jusdl.Components.Sinks.Printer","page":"Printer","title":"Jusdl.Components.Sinks.Printer","text":"Printer(input::Bus{Union{Missing, T}}, buflen=64, plugin=nothing) where T\n\nConstructs a Printer with input bus input. buflen is the length of its internal buflen. plugin is data proccessing tool.\n\n\n\n\n\n","category":"type"},{"location":"manual/components/sinks/printer/#Base.print-Tuple{Printer,Any,Any}","page":"Printer","title":"Base.print","text":"print(printer::Printer, td, xd)\n\nPrints xd corresponding to xd to the console.\n\n\n\n\n\n","category":"method"},{"location":"manual/components/sinks/printer/#Base.open-Tuple{Printer}","page":"Printer","title":"Base.open","text":"open(printer::Printer)\n\nDoes nothing. Just a common interface function ot AbstractSink interface.\n\n\n\n\n\n","category":"method"},{"location":"manual/components/sinks/printer/#Base.close-Tuple{Printer}","page":"Printer","title":"Base.close","text":"close(printer::Printer)\n\nDoes nothing. Just a common interface function ot AbstractSink interface.\n\n\n\n\n\n","category":"method"},{"location":"manual/components/systems/staticsystems/network/#Network-1","page":"Network","title":"Network","text":"","category":"section"},{"location":"manual/components/systems/staticsystems/network/#","page":"Network","title":"Network","text":"A Network is a system consisting of connected systems. That is, a Network is actually modelled as a SubSystem.","category":"page"},{"location":"manual/components/systems/staticsystems/network/#Construction-of-Networks-1","page":"Network","title":"Construction of Networks","text":"","category":"section"},{"location":"manual/components/systems/staticsystems/network/#","page":"Network","title":"Network","text":"To construct a Network we have to specify the components, the outer connectivity matrix and the inner coupling matrix. Inputs and outputs can be assigned to the Network. See the main constructor.","category":"page"},{"location":"manual/components/systems/staticsystems/network/#","page":"Network","title":"Network","text":"Network","category":"page"},{"location":"manual/components/systems/staticsystems/network/#Jusdl.Components.Systems.SubSystems.Network","page":"Network","title":"Jusdl.Components.Systems.SubSystems.Network","text":"Network(nodes, conmat, cplmat; inputnodeidx, outputnodeidx, clusters)\n\nConstructs a Network consisting of nodes with the connection matrix conmat and the coupling matrix cplmat. The dynamics of the Network evolves by,\n\n    dotx_i = f(x_i) + sum_j = 1^n epsilon_ij P x_j quad i = 1 ldots n\n\nwhere n is the number of nodes, f is the function corresponding to individual node dynamics, epsilon_ij is the coupling strength between nodes i and j. The diagonal matrix P determines the state variables through which the nodes are coupled. In the equation above, we have conmat is eqaul to E = epsilon_ij and cplmat is eqaul to P.\n\ninputnodeidx and outputnodeidx is the input and output node indices for the input and output, respectively. clusters is the set of indices of node groups in the same cluster. inputnodeidx and outputnodeidx may be of type Nothing, Bus or Vector{<:Link}.\n\n\n\n\n\n","category":"type"},{"location":"manual/components/systems/staticsystems/network/#","page":"Network","title":"Network","text":"Let us continue with examples. We first construct a couple of dynamical systems.","category":"page"},{"location":"manual/components/systems/staticsystems/network/#","page":"Network","title":"Network","text":"using Jusdl # hide \nnodes = [LorenzSystem(Bus(3), Bus(3)) for i = 1 : 5]","category":"page"},{"location":"manual/components/systems/staticsystems/network/#","page":"Network","title":"Network","text":"Then, we connect the outer coupling matrix ","category":"page"},{"location":"manual/components/systems/staticsystems/network/#","page":"Network","title":"Network","text":"conmat = topology(:star_graph, 5, weight=5.)","category":"page"},{"location":"manual/components/systems/staticsystems/network/#","page":"Network","title":"Network","text":"and we construct the inner coupling matrix","category":"page"},{"location":"manual/components/systems/staticsystems/network/#","page":"Network","title":"Network","text":"cplmat = coupling(3, 1)","category":"page"},{"location":"manual/components/systems/staticsystems/network/#","page":"Network","title":"Network","text":"Now we are ready to construct the Network.","category":"page"},{"location":"manual/components/systems/staticsystems/network/#","page":"Network","title":"Network","text":"net = Network(nodes, conmat, cplmat)","category":"page"},{"location":"manual/components/systems/staticsystems/network/#Connection-Matrices-1","page":"Network","title":"Connection Matrices","text":"","category":"section"},{"location":"manual/components/systems/staticsystems/network/#","page":"Network","title":"Network","text":"The outer connection matrix determines the topology and the strength of the links between the nodes of the network. There exist some methods for easy construction of outer connection matrices.","category":"page"},{"location":"manual/components/systems/staticsystems/network/#","page":"Network","title":"Network","text":"topology\ncgsconnectivity\nclusterconnectivity","category":"page"},{"location":"manual/components/systems/staticsystems/network/#Jusdl.Components.Systems.SubSystems.topology","page":"Network","title":"Jusdl.Components.Systems.SubSystems.topology","text":"topology(name::Symbol, args...; weight::Real=1., timevarying::Bool=false)\n\nReturns an outer connectivity matrix whose graph is given by name. weight is the scaling vector of the connection matrix. If timevarying is true, all elements of the connectivity matrix is a function of time t.\n\nnote: Note\nSee (https://juliagraphs.github.io/LightGraphs.jl/latest/generators/#Graph-Generators-1) for different names.\n\nExample\n\njulia> topology(:path_graph, 5, weight=10)\n5×5 Array{Int64,2}:\n -10   10    0    0    0\n  10  -20   10    0    0\n   0   10  -20   10    0\n   0    0   10  -20   10\n   0    0    0   10  -10\n\n\n\n\n\n","category":"function"},{"location":"manual/components/systems/staticsystems/network/#Jusdl.Components.Systems.SubSystems.cgsconnectivity","page":"Network","title":"Jusdl.Components.Systems.SubSystems.cgsconnectivity","text":"cgsconnectivity(graph::AbstractGraph; weight::Real=1., timevarying::Bool=false)\n\nConstructs an outer connnectivity matrix corresponding to connection graph stability method. graph is graph of the network, weight scales the connectivity matrix. If timevarying is true, each element of the connnectivity matrix is a function of time t.\n\ncgsconnectivity(adjmat::AbstractMatrix; weight::Real=1.,  timevarying::Bool=false)\n\nConstructs an outer connnectivity matrix corresponding to connection graph stability method. adjmat is the adjacency matrix of the network, weight scales the connectivity matrix. If timevarying is true, each element of the connnectivity matrix is a function of time t.\n\ncgsconnectivity(topology::Symbol, args...; weight::Real=1., timevarying::Bool=false, kwargs...)\n\nConstructs an outer connnectivity matrix corresponding to connection graph stability method. topology is the name of the graph of the network, weight scales the connectivity matrix. If timevarying is true, each element of the connnectivity matrix is a function of time t.\n\nExample\n\njulia> cgsconnectivity(:path_graph, 5)\n5×5 Array{Float64,2}:\n -0.8   0.8   0.0   0.0   0.0\n  0.8  -2.0   1.2   0.0   0.0\n  0.0   1.2  -2.4   1.2   0.0\n  0.0   0.0   1.2  -2.0   0.8\n  0.0   0.0   0.0   0.8  -0.8\n\nReferences\n\nBelykh, V. N., Belykh, I. V., & Hasler, M. (2004). Connection graph stability method for synchronized coupled chaotic systems. Physica D: nonlinear phenomena, 195(1-2), 159-187.\n\n\n\n\n\n","category":"function"},{"location":"manual/components/systems/staticsystems/network/#Jusdl.Components.Systems.SubSystems.clusterconnectivity","page":"Network","title":"Jusdl.Components.Systems.SubSystems.clusterconnectivity","text":"clusterconnectivity(clusters::AbstractRange...; weight=1., timevarying::Bool=false)\n\nConstruct an outer connnectivity matrix using arbitrary clusters method. clusters is the set of node indices in each clusters. weight scales the connectivity matrix. If  timevarying is true, all elements of the connectivity matrix is a function of time t.\n\nExample\n\njulia> clusterconnectivity(1:2, 3:6)\n6×6 Array{Float64,2}:\n -3.0   3.0  -1.0   1.0   0.0   0.0\n  3.0  -3.0   1.0  -1.0   0.0   0.0\n -1.0   1.0  -9.0   3.0   3.0   3.0\n  1.0  -1.0   3.0  -9.0   3.0   3.0\n  0.0   0.0   3.0   3.0  -9.0   3.0\n  0.0   0.0   3.0   3.0   3.0  -9.0\n\nReferences\n\nMa, Z., Liu, Z., & Zhang, G. (2006). A new method to realize cluster synchronization in connected chaotic networks. Chaos: An Interdisciplinary Journal of Nonlinear Science, 16(2), 023103.\n\n\n\n\n\n","category":"function"},{"location":"manual/components/systems/staticsystems/network/#Plotting-of-Network-1","page":"Network","title":"Plotting of Network","text":"","category":"section"},{"location":"manual/components/systems/staticsystems/network/#","page":"Network","title":"Network","text":"It is also possible to plot the networks. Use gplot function for this purpose. ","category":"page"},{"location":"manual/components/systems/staticsystems/network/#","page":"Network","title":"Network","text":"gplot","category":"page"},{"location":"manual/components/systems/staticsystems/network/#GraphPlot.gplot","page":"Network","title":"GraphPlot.gplot","text":"gplplot(net::Network, args...; kwargs...)\n\nPlots net.\n\n\n\n\n\n","category":"function"},{"location":"manual/components/systems/staticsystems/network/#Modifying-Networks-1","page":"Network","title":"Modifying Networks","text":"","category":"section"},{"location":"manual/components/systems/staticsystems/network/#","page":"Network","title":"Network","text":"The Networks can be modified through its connections. For example, the weight of the connection between nodes of the network can be changed or a connection can be deleted.","category":"page"},{"location":"manual/components/systems/staticsystems/network/#","page":"Network","title":"Network","text":"changeweight\ndeletelink","category":"page"},{"location":"manual/components/systems/staticsystems/network/#Jusdl.Components.Systems.SubSystems.changeweight","page":"Network","title":"Jusdl.Components.Systems.SubSystems.changeweight","text":"changeweight(net::Network, src::Int, dst::Int, weight)\n\nChanges the weight of the coupling between the nodes src and dst with weight.\n\n\n\n\n\n","category":"function"},{"location":"manual/components/systems/staticsystems/network/#Jusdl.Components.Systems.SubSystems.deletelink","page":"Network","title":"Jusdl.Components.Systems.SubSystems.deletelink","text":"deletelink(net::Network, src::Int, dst::Int)\n\nChanges the strength of the link between src and dst to zero.\n\n\n\n\n\n","category":"function"},{"location":"manual/components/systems/staticsystems/network/#Full-API-1","page":"Network","title":"Full API","text":"","category":"section"},{"location":"manual/components/systems/staticsystems/network/#","page":"Network","title":"Network","text":"nodes(net::Network)\nnumnodes(net::Network)\ndimnodes(net::Network)\ncoupling\nmaketimevarying","category":"page"},{"location":"manual/components/systems/staticsystems/network/#Jusdl.Components.Systems.SubSystems.nodes-Tuple{Network}","page":"Network","title":"Jusdl.Components.Systems.SubSystems.nodes","text":"nodes(net::Network)\n\nReturns the nodes of net. nodes are the dynamical system components of net.\n\n\n\n\n\n","category":"method"},{"location":"manual/components/systems/staticsystems/network/#Jusdl.Components.Systems.SubSystems.numnodes-Tuple{Network}","page":"Network","title":"Jusdl.Components.Systems.SubSystems.numnodes","text":"numnodes(net::Network)\n\nReturns the number of nodes in net.\n\n\n\n\n\n","category":"method"},{"location":"manual/components/systems/staticsystems/network/#Jusdl.Components.Systems.SubSystems.dimnodes-Tuple{Network}","page":"Network","title":"Jusdl.Components.Systems.SubSystems.dimnodes","text":"dimnodes(net::Network)\n\nReturns the dimension of nodes in net.\n\n\n\n\n\n","category":"method"},{"location":"manual/components/systems/staticsystems/network/#Jusdl.Components.Systems.SubSystems.coupling","page":"Network","title":"Jusdl.Components.Systems.SubSystems.coupling","text":"coupling(d, idx::Vector{Int})\n\nReturns a d-by-d diagonal matrix whose diagonal elements are ones corresponding to idx.\n\ncoupling(d, idx::Int)\n\nReturns a d-by-d diagonal matrix whose diagonal element is one corresponding to idx.\n\nExample\n\njulia> coupling(3, [1, 2])\n3×3 Array{Float64,2}:\n 1.0  0.0  0.0\n 0.0  1.0  0.0\n 0.0  0.0  0.0\n\njulia> coupling(3, 1)\n3×3 Array{Float64,2}:\n 1.0  0.0  0.0\n 0.0  0.0  0.0\n 0.0  0.0  0.0\n\n\n\n\n\n","category":"function"},{"location":"manual/components/systems/staticsystems/network/#Jusdl.Components.Systems.SubSystems.maketimevarying","page":"Network","title":"Jusdl.Components.Systems.SubSystems.maketimevarying","text":"maketimevarying(mat::AbstractMatrix{<:Real})\n\nReturns a matrix of function of time t corresponding to mat.\n\nExample\n\njulia> a = collect(reshape(1:9, 3, 3))\n3×3 Array{Int64,2}:\n 1  4  7\n 2  5  8\n 3  6  9\n\njulia> b = maketimevarying(a);\n\njulia> b[1, 1](0.)\n1\n\njulia> b[3, 2](0.)\n6\n\n\n\n\n\n","category":"function"},{"location":"manual/components/systems/dynamicsystems/sdesystem/#SDESystem-1","page":"SDESystem","title":"SDESystem","text":"","category":"section"},{"location":"manual/components/systems/dynamicsystems/sdesystem/#Construction-of-SDESystems-1","page":"SDESystem","title":"Construction of SDESystems","text":"","category":"section"},{"location":"manual/components/systems/dynamicsystems/sdesystem/#","page":"SDESystem","title":"SDESystem","text":"A SDESystem is represented by the state function ","category":"page"},{"location":"manual/components/systems/dynamicsystems/sdesystem/#","page":"SDESystem","title":"SDESystem","text":"    dx = f(x u t) dt + h(x u t)dW ","category":"page"},{"location":"manual/components/systems/dynamicsystems/sdesystem/#","page":"SDESystem","title":"SDESystem","text":"where t is the time, x in R^n is the value of state, u in R^p is the value of the input. W is the Wiener process of the system. The output function is defined by ","category":"page"},{"location":"manual/components/systems/dynamicsystems/sdesystem/#","page":"SDESystem","title":"SDESystem","text":"    y = g(x u t)","category":"page"},{"location":"manual/components/systems/dynamicsystems/sdesystem/#","page":"SDESystem","title":"SDESystem","text":"where y is the value of output at time t. ","category":"page"},{"location":"manual/components/systems/dynamicsystems/sdesystem/#","page":"SDESystem","title":"SDESystem","text":"As an example consider a system with the following stochastic differential equation ","category":"page"},{"location":"manual/components/systems/dynamicsystems/sdesystem/#","page":"SDESystem","title":"SDESystem","text":"    beginarrayl\n        dx = -x dt - x dW\n    endarray","category":"page"},{"location":"manual/components/systems/dynamicsystems/sdesystem/#","page":"SDESystem","title":"SDESystem","text":"and the following output equation ","category":"page"},{"location":"manual/components/systems/dynamicsystems/sdesystem/#","page":"SDESystem","title":"SDESystem","text":"y = x","category":"page"},{"location":"manual/components/systems/dynamicsystems/sdesystem/#","page":"SDESystem","title":"SDESystem","text":"The state function statefunc and the output function outputfunc is defined as follows.","category":"page"},{"location":"manual/components/systems/dynamicsystems/sdesystem/#","page":"SDESystem","title":"SDESystem","text":"using Jusdl # hide \nf(dx, x, u, t) = (dx[1] = -x[1])\nh(dx, x, u, t) = (dx[1] = -x[1])","category":"page"},{"location":"manual/components/systems/dynamicsystems/sdesystem/#","page":"SDESystem","title":"SDESystem","text":"The state function statefunc is the tuple of drift and diffusion functions","category":"page"},{"location":"manual/components/systems/dynamicsystems/sdesystem/#","page":"SDESystem","title":"SDESystem","text":"statefunc = (f, h)","category":"page"},{"location":"manual/components/systems/dynamicsystems/sdesystem/#","page":"SDESystem","title":"SDESystem","text":"The output function outputfunc is defined as,","category":"page"},{"location":"manual/components/systems/dynamicsystems/sdesystem/#","page":"SDESystem","title":"SDESystem","text":"g(x, u, t) = x","category":"page"},{"location":"manual/components/systems/dynamicsystems/sdesystem/#","page":"SDESystem","title":"SDESystem","text":"Note that the in drift function f and diffusion function g, the vector dx is mutated while in the output function g no mutation is done, but the output value is generated instead.","category":"page"},{"location":"manual/components/systems/dynamicsystems/sdesystem/#","page":"SDESystem","title":"SDESystem","text":"From the definition of drift function f and the diffusion function g, it is seen that the system does not have any input, that is, the input of the system is nothing. Since all the state variables are taken as outputs, the system needs an output bus of length 1. Thus, ","category":"page"},{"location":"manual/components/systems/dynamicsystems/sdesystem/#","page":"SDESystem","title":"SDESystem","text":"input = nothing \noutput = Bus(1)","category":"page"},{"location":"manual/components/systems/dynamicsystems/sdesystem/#","page":"SDESystem","title":"SDESystem","text":"At this point, we are ready to construct the system ds.","category":"page"},{"location":"manual/components/systems/dynamicsystems/sdesystem/#","page":"SDESystem","title":"SDESystem","text":"ds = SDESystem(input, output, statefunc, g, [1.], 0.)","category":"page"},{"location":"manual/components/systems/dynamicsystems/sdesystem/#Basic-Operation-of-SDESystems-1","page":"SDESystem","title":"Basic Operation of SDESystems","text":"","category":"section"},{"location":"manual/components/systems/dynamicsystems/sdesystem/#","page":"SDESystem","title":"SDESystem","text":"The basic operation of a SDESystem is the same as those of other dynamical systems. When triggered from its trigger link, a SDESystem reads its time t from its trigger link, reads its input value from its input, solves its state equation, which is a stochastic differential equation, computes its output and writes its computed output to its output bus. ","category":"page"},{"location":"manual/components/systems/dynamicsystems/sdesystem/#","page":"SDESystem","title":"SDESystem","text":"In this section, we continue with the system ds constructed in the previous section. To make ds drivable, we need to launch it.","category":"page"},{"location":"manual/components/systems/dynamicsystems/sdesystem/#","page":"SDESystem","title":"SDESystem","text":"task = launch(ds)","category":"page"},{"location":"manual/components/systems/dynamicsystems/sdesystem/#","page":"SDESystem","title":"SDESystem","text":"When launched, ds can be driven. For this, either of the syntax put!(ds.trigger, t) or drive(ds, t) can be used. ","category":"page"},{"location":"manual/components/systems/dynamicsystems/sdesystem/#","page":"SDESystem","title":"SDESystem","text":"drive(ds, 1.)","category":"page"},{"location":"manual/components/systems/dynamicsystems/sdesystem/#","page":"SDESystem","title":"SDESystem","text":"After this command, ds reads its time t from its trigger link, solves its state function and computes its output. The calculated output value is written to the buffer of output. To signal that, the step is takes with success, ds writes true to its handshake link. To further drive ds, this handshake link must be read. For this either of the syntax, take!(ds.handshake) or approve(ds) can be used","category":"page"},{"location":"manual/components/systems/dynamicsystems/sdesystem/#","page":"SDESystem","title":"SDESystem","text":"ds.handshake \ntake!(ds.handshake)","category":"page"},{"location":"manual/components/systems/dynamicsystems/sdesystem/#","page":"SDESystem","title":"SDESystem","text":"At this point, we can further drive ds. ","category":"page"},{"location":"manual/components/systems/dynamicsystems/sdesystem/#","page":"SDESystem","title":"SDESystem","text":"for t in 2. : 10.\n    drive(ds, t)\n    approve(ds)\nend","category":"page"},{"location":"manual/components/systems/dynamicsystems/sdesystem/#","page":"SDESystem","title":"SDESystem","text":"Note that during the evolution, the output of ds is written into the buffers of output bus.","category":"page"},{"location":"manual/components/systems/dynamicsystems/sdesystem/#","page":"SDESystem","title":"SDESystem","text":"ds.output[1].buffer.data","category":"page"},{"location":"manual/components/systems/dynamicsystems/sdesystem/#","page":"SDESystem","title":"SDESystem","text":"warning: Warning\nThe values of the output is written into buffers if the output of the systems is not nothing.","category":"page"},{"location":"manual/components/systems/dynamicsystems/sdesystem/#","page":"SDESystem","title":"SDESystem","text":"When we launched ds, we constructed a task whose state is running which implies that the ds can be drivable. As long as this task is running, ds can be drivable. ","category":"page"},{"location":"manual/components/systems/dynamicsystems/sdesystem/#","page":"SDESystem","title":"SDESystem","text":"warning: Warning\nThe state of the task is different from running in case an exception is thwown. ","category":"page"},{"location":"manual/components/systems/dynamicsystems/sdesystem/#","page":"SDESystem","title":"SDESystem","text":"To terminate the task securely, we need to terminate ds securely. To do that, can use terminate(ds).","category":"page"},{"location":"manual/components/systems/dynamicsystems/sdesystem/#","page":"SDESystem","title":"SDESystem","text":"terminate(ds)","category":"page"},{"location":"manual/components/systems/dynamicsystems/sdesystem/#","page":"SDESystem","title":"SDESystem","text":"Note that the task is terminated without a hassle. ","category":"page"},{"location":"manual/components/systems/dynamicsystems/sdesystem/#","page":"SDESystem","title":"SDESystem","text":"task","category":"page"},{"location":"manual/components/systems/dynamicsystems/sdesystem/#Full-API-1","page":"SDESystem","title":"Full API","text":"","category":"section"},{"location":"manual/components/systems/dynamicsystems/sdesystem/#","page":"SDESystem","title":"SDESystem","text":"SDESystem ","category":"page"},{"location":"manual/components/systems/dynamicsystems/sdesystem/#Jusdl.Components.Systems.DynamicSystems.SDESystem","page":"SDESystem","title":"Jusdl.Components.Systems.DynamicSystems.SDESystem","text":"SDESystem(input, output, statefunc, outputfunc, state, t; noise=Noise(WienerProcess(0., zeros(length(state)))), solver=SDESolver)\n\nConstructs a SDESystem with input and output. statefunc is the state function and outputfunc is the output function of SDESystem. The SDESystem is represented by the state equation\n\n    beginarrayl\n        dx = f(x u t) dt + h(x u t)dW \n        y = g(x u t)\n    endarray\n\nwhere f is the drift equation and h is the diffusion equation.  The statefunc is the tuple of drift function f and diffusion function h i.e. statefunc = (f, h). g is outputfunc. t is the time t, x is the state, u is the value of input and y is the value of the output. W is the Wiever process. noise is the noise of the system and solver is used to solve the above differential equation.\n\nThe syntax of the drift and diffusion function of statefunc must be of the form\n\nfunction f(dx, x, u, t)\n    dx .= ... # Update dx\nend\nfunction h(dx, x, u, t)\n    dx .= ... # Update dx.\nend\n\nand the syntax of outputfunc must be of the form \n\nfunction outputfunc(x, u, t)\n    y = ... # Compute y \n    return y\nend\n\nExample\n\njulia> f(dx, x, u, t) = (dx[1] = -x[1])\nf (generic function with 1 method)\n\njulia> h(dx, x, u, t) = (dx[1] = -x[1])\nh (generic function with 1 method)\n\njulia> g(x, u, t) = x\ng (generic function with 1 method)\n\njulia> ds = SDESystem(nothing, Bus(), (f,h), g, [1.], 0.)\nSDESystem(state:[1.0], t:0.0, input:nothing, output:Bus(nlinks:1, eltype:Link{Float64}, isreadable:false, iswritable:false), noise:Noise(process:t: [0.0]\nu: Array{Float64,1}[[0.0]], prototype:nothing, seed:0))\n\n\n\n\n\n","category":"type"},{"location":"manual/components/sinks/sinks/#Sinks-1","page":"Sinks","title":"Sinks","text":"","category":"section"},{"location":"manual/components/sinks/sinks/#","page":"Sinks","title":"Sinks","text":"Sinks are used to simulation data flowing through the connections of the model. The data processing is done online during the simulation. Sink type is a subtype of AbstractSink. An AbstractSink is also a subtype of AbstractComponent (see Components),  so an AbstractSink instance has a trigger link to be triggered and a handshake link to signal that evolution is succeeded. In addition, an AbstractSink has an input buffer inbuf whose mode is Cyclic. When an AbstractSink instance is triggered through its trigger link, it basically reads its incoming data and writes to its input buffer inbuf. When its input buffer inbuf is full, the data in inbuf is processed according to the type of AbstractSink. Jusdl provides three concrete subtypes of AbstractSink which are Writer, Printer and Scope. As the operation of an AbstractSink depends only incoming data, an AbstractSink does not have an output.","category":"page"},{"location":"manual/connections/link/#Links-1","page":"Links","title":"Links","text":"","category":"section"},{"location":"manual/connections/link/#","page":"Links","title":"Links","text":"DocTestSetup  = quote\n    using Jusdl\nend","category":"page"},{"location":"manual/connections/link/#","page":"Links","title":"Links","text":"Links are built on top of  Channels of Julia. They are used as communication primitives for Tasks of Julia. A Link basically includes a Channel and a Buffer. The mode of the buffer is Cyclic.(see Buffer Modes for information on buffer modes). Every item sent through a Link is sent through the channel of the Link and written to the Buffer so that all the data flowing through a Link is recorded. The data transmitted through a Link can be of any Julia type, even if user-defined types. ","category":"page"},{"location":"manual/connections/link/#Construction-of-Links-1","page":"Links","title":"Construction of Links","text":"","category":"section"},{"location":"manual/connections/link/#","page":"Links","title":"Links","text":"The construction of a Link is very simple: just specify its buffer length and element type.","category":"page"},{"location":"manual/connections/link/#","page":"Links","title":"Links","text":"Link","category":"page"},{"location":"manual/connections/link/#Jusdl.Connections.Link","page":"Links","title":"Jusdl.Connections.Link","text":"Link{T}(ln::Int=64) where T\n\nConstructs a Link with element type T and buffer length ln. The buffer element type is T and mode is Cyclic.\n\nLink(ln::Int=64)\n\nConstructs a Link with element type Float64 and buffer length ln. The buffer element type is Float64 and mode is Cyclic.\n\n\n\n\n\n","category":"type"},{"location":"manual/connections/link/#","page":"Links","title":"Links","text":"Here, are some examples.","category":"page"},{"location":"manual/connections/link/#","page":"Links","title":"Links","text":"using Jusdl # hide \nl1 = Link{Int}(5)\nl2 = Link{Matrix{Float64}}(10)","category":"page"},{"location":"manual/connections/link/#","page":"Links","title":"Links","text":"Similar to the case of Buffers, the data type that can flow the Link can be any Julia type, even a user-defined type. ","category":"page"},{"location":"manual/connections/link/#","page":"Links","title":"Links","text":"using Jusdl # hide\nstruct Object\n    x::Int \nend \nl = Link{Object}(3)     # A `Link` that with element type `Object` with buffer size `3`.","category":"page"},{"location":"manual/connections/link/#Connection-and-Disconnection-of-Links-1","page":"Links","title":"Connection and Disconnection of Links","text":"","category":"section"},{"location":"manual/connections/link/#","page":"Links","title":"Links","text":"Links can be connected to each other so that data can flow from one link to another. The flows from link l1 to l2, then l1 is said to drive l2 and l1 is called as master and l2 is called as slave. A Link can have more than one slave but can have just one master. When a Links is initialized, it has no master and slaves.","category":"page"},{"location":"manual/connections/link/#","page":"Links","title":"Links","text":"connect ","category":"page"},{"location":"manual/connections/link/#Jusdl.Connections.connect","page":"Links","title":"Jusdl.Connections.connect","text":"connect(master::Link, slave::Link)\n\nConnects master to slave. When connected, any element that is put into master is also put into slave. \n\nconnect(master::AbstractVector{<:Link}, slave::AbstractVector{<:Link})\n\nConnects each link in master to each link in slave one by one.\n\nExample\n\njulia> l1, l2 = Link(), Link();\n\njulia> connect(l1, l2)\n\njulia> l2.master[] == l1\ntrue\n\n\n\n\n\n","category":"function"},{"location":"manual/connections/link/#","page":"Links","title":"Links","text":"Similarly Links can be disconnected. ","category":"page"},{"location":"manual/connections/link/#","page":"Links","title":"Links","text":"disconnect","category":"page"},{"location":"manual/connections/link/#Jusdl.Connections.disconnect","page":"Links","title":"Jusdl.Connections.disconnect","text":"disconnect(link1::Link, link2::Link)\n\nDisconnects link1 and link2. The order of arguments is not important. See also: connect\n\n\n\n\n\n","category":"function"},{"location":"manual/connections/link/#","page":"Links","title":"Links","text":"warning: Warning\nNote that the order or arguments is important when the links are connected. connect(l1, l2) connects l1 and l2 such that l1 drives l2, i.e., data flows from l1 to l2. In other words, l1 is the master link and l2 is the slave link. However, the order of arguments is not important when the links are disconnected. disconnect(l1, l2) does the same thing with disconnect(l2, l1), i.e., it justs breaks the connection between l2 and l1.","category":"page"},{"location":"manual/connections/link/#Data-Flow-through-Links-1","page":"Links","title":"Data Flow through Links","text":"","category":"section"},{"location":"manual/connections/link/#","page":"Links","title":"Links","text":"The data can be read from and written into Links if active tasks are bound to them. Links can be thought of a pipe. In order to write data to a Link from one of its ends, a task that reads written data from the other end must be bounded to the Link. Similarly, in order to read data from one of the Link from one of its end, a task that writes the read data must be bound to the Link. Reading from and writing to Link is carried out with take! and put! functions. For more clarity, let us see some example. ","category":"page"},{"location":"manual/connections/link/#","page":"Links","title":"Links","text":"Let us first construct a Link,","category":"page"},{"location":"manual/connections/link/#","page":"Links","title":"Links","text":"using Jusdl # hide\nl = Link{Float64}(5)","category":"page"},{"location":"manual/connections/link/#","page":"Links","title":"Links","text":"l is a Link with a buffer length of 5 and element type of Float64. Not that the l is open, but it is not ready for data reading or writing. To write data, we must bound a task that reads the written data.","category":"page"},{"location":"manual/connections/link/#","page":"Links","title":"Links","text":"function reader(link::Link)  # Define job.\n    while true\n        val = take!(link)\n        val === missing && break  # Poison-pill the tasks to terminate safely.\n    end\nend\nt = @async reader(l)","category":"page"},{"location":"manual/connections/link/#","page":"Links","title":"Links","text":"The reader is defined such that the data written from one end of l is read until the data is missing. Now, we have runnable task t. This means the l is ready for data writing. ","category":"page"},{"location":"manual/connections/link/#","page":"Links","title":"Links","text":"put!(l, 1.)\nput!(l, 2.)","category":"page"},{"location":"manual/connections/link/#","page":"Links","title":"Links","text":"To terminate the task, we must write missing to l.","category":"page"},{"location":"manual/connections/link/#","page":"Links","title":"Links","text":"put!(l, missing)  # Terminate the task \nt   # Show that the `t` is terminated.","category":"page"},{"location":"manual/connections/link/#","page":"Links","title":"Links","text":"Note that the data flown through the l is written to its buffer. ","category":"page"},{"location":"manual/connections/link/#","page":"Links","title":"Links","text":"l.buffer.data","category":"page"},{"location":"manual/connections/link/#","page":"Links","title":"Links","text":"When ever the bound task to the l is runnable, the data can be written to l. That is, the data length that can be written to l is not limited by the buffer length of l. But, beware that the buffer of Linkss are Cyclic. That means, when the buffer is full, its data is overwritten.","category":"page"},{"location":"manual/connections/link/#","page":"Links","title":"Links","text":"l = Link(5)\nt = @async reader(l)\nfor item in 1. : 10.\n    put!(l, item)\n    @show l.buffer.data\nend","category":"page"},{"location":"manual/connections/link/#","page":"Links","title":"Links","text":"The case is very similar to read data from l. Again a runnable task is bound the l ","category":"page"},{"location":"manual/connections/link/#","page":"Links","title":"Links","text":"using Jusdl # hide\nl = Link(5)\nfunction writer(link::Link, vals)\n    for val in vals\n        put!(link, val)\n    end\nend\nt = @async writer(l, 1.:5.)\nbind(l, t)\ntake!(l)\ntake!(l)","category":"page"},{"location":"manual/connections/link/#","page":"Links","title":"Links","text":"It is possible to read data from l until t is active. To read all the data at once, collect can be used. ","category":"page"},{"location":"manual/connections/link/#","page":"Links","title":"Links","text":"t   \ncollect(l)\nt  # Show that `t` is terminated.","category":"page"},{"location":"manual/connections/link/#Full-API-1","page":"Links","title":"Full API","text":"","category":"section"},{"location":"manual/connections/link/#","page":"Links","title":"Links","text":"Connections.put!(link::Link, val)\nConnections.take!(link::Link)\nConnections.close(link::Link)\nConnections.isopen(link::Link)\nConnections.isreadable(link::Link)\nConnections.iswritable(link::Link)\nConnections.isfull(link::Link)\nConnections.isconnected\nConnections.hasslaves(link::Link) \nConnections.hasmaster(link::Link)\nConnections.getmaster(link::Link) \nConnections.getslaves(link::Link)\nConnections.snapshot(link::Link) \nConnections.Connections.UnconnectedLinkError\nConnections.Connections.Pin\nConnections.findflow(link1::Link, link2::Link) \nConnections.insert\nConnections.release\nConnections.bind\nConnections.collect(link::Link)\nConnections.launch(link::Link) \nConnections.launch(link::Link, valrange) ","category":"page"},{"location":"manual/connections/link/#Base.put!-Tuple{Link,Any}","page":"Links","title":"Base.put!","text":"put!(link::Link, val)\n\nPuts val to link. val is handed over to the channel of link. val is also written in to the buffer of link.\n\nwarning: Warning\nlink must be writable to put val. That is, a runnable task that takes items from the link must be bounded to link.\n\nExample\n\njulia> l = Link();\n\njulia> t  = @async while true \n       item = take!(l)\n       item === NaN && break \n       println(\"Took \" * string(item))\n       end;\n\njulia> bind(l, t);\n\njulia> put!(l, 1.)\nTook 1.0\n1.0\n\njulia> put!(l, 2.)\nTook 2.0\n2.0\n\njulia> put!(l, NaN)\nNaN\n\n\n\n\n\n","category":"method"},{"location":"manual/connections/link/#Base.take!-Tuple{Link}","page":"Links","title":"Base.take!","text":"take!(link::Link)\n\nTake an element from link.\n\nwarning: Warning\nlink must be readable to take value. That is, a runnable task that puts items from the link must be bounded to link.\n\nExample\n\njulia> l = Link(5);\n\njulia> t = @async for item in 1. : 5.\n       put!(l, item)\n       end;\n\njulia> bind(l, t);\n\njulia> take!(l)\n1.0\n\njulia> take!(l)\n2.0\n\n\n\n\n\n","category":"method"},{"location":"manual/connections/link/#Base.close-Tuple{Link}","page":"Links","title":"Base.close","text":"close(link)\n\nCloses link. All the task bound the link is also terminated safely. When closed, it is not possible to take and put element from the link. See also: take!(link::Link), put!(link::Link, val) ```\n\n\n\n\n\n","category":"method"},{"location":"manual/connections/link/#Base.isopen-Tuple{Link}","page":"Links","title":"Base.isopen","text":"isopen(link::Link)\n\nReturns true if link is open. A link is open if its channel is open.\n\n\n\n\n\n","category":"method"},{"location":"manual/connections/link/#Base.isreadable-Tuple{Link}","page":"Links","title":"Base.isreadable","text":"isreadable(link::Link)\n\nReturns true if link is readable. When link is readable, data can be read from link with take function.\n\n\n\n\n\n","category":"method"},{"location":"manual/connections/link/#Base.iswritable-Tuple{Link}","page":"Links","title":"Base.iswritable","text":"writable(link::Link)\n\nReturns true if link is writable. When link is writable, data can be written into link with put function.\n\n\n\n\n\n","category":"method"},{"location":"manual/connections/link/#Jusdl.Connections.isfull-Tuple{Link}","page":"Links","title":"Jusdl.Connections.isfull","text":"isfull(link::Link)\n\nReturns true if the buffer of link is full.\n\n\n\n\n\n","category":"method"},{"location":"manual/connections/link/#Jusdl.Connections.isconnected","page":"Links","title":"Jusdl.Connections.isconnected","text":"isconnected(link1, link2)\n\nReturns true if link1 is connected to link2. The order of the arguments are not important.\n\n\n\n\n\n","category":"function"},{"location":"manual/connections/link/#Jusdl.Connections.hasslaves-Tuple{Link}","page":"Links","title":"Jusdl.Connections.hasslaves","text":"hasslaves(link::Link)\n\nReturns true if link has slave links.\n\n\n\n\n\n","category":"method"},{"location":"manual/connections/link/#Jusdl.Connections.hasmaster-Tuple{Link}","page":"Links","title":"Jusdl.Connections.hasmaster","text":"hasmaster(link::Link)\n\nReturns true if link has a master link.\n\n\n\n\n\n","category":"method"},{"location":"manual/connections/link/#Jusdl.Connections.getmaster-Tuple{Link}","page":"Links","title":"Jusdl.Connections.getmaster","text":"getmaster(link::Link)\n\nReturns the master of link.\n\n\n\n\n\n","category":"method"},{"location":"manual/connections/link/#Jusdl.Connections.getslaves-Tuple{Link}","page":"Links","title":"Jusdl.Connections.getslaves","text":"getslaves(link::Link)\n\nReturns the slaves of link.\n\n\n\n\n\n","category":"method"},{"location":"manual/connections/link/#Jusdl.Connections.snapshot-Tuple{Link}","page":"Links","title":"Jusdl.Connections.snapshot","text":"snapshot(link::Link)\n\nReturns all the data of the buffer of link.\n\n\n\n\n\n","category":"method"},{"location":"manual/connections/link/#Jusdl.Connections.UnconnectedLinkError","page":"Links","title":"Jusdl.Connections.UnconnectedLinkError","text":"UnconnectedLinkError <: Exception\n\nException thrown when the links are not connected to each other.\n\n\n\n\n\n","category":"type"},{"location":"manual/connections/link/#Jusdl.Connections.Pin","page":"Links","title":"Jusdl.Connections.Pin","text":"Pin()\n\nConstructs a Pin. A Pin is the auxilary type to monitor connection status of Links. See Link\n\n\n\n\n\n","category":"type"},{"location":"manual/connections/link/#Jusdl.Connections.findflow-Tuple{Link,Link}","page":"Links","title":"Jusdl.Connections.findflow","text":"findflow(link1::Link, link2::Link)\n\nReturns a tuple of (masterlink, slavelink) where masterlink is the link that drives the other and slavelink is the link that is driven by the other.\n\nExample\n\njulia> ls = [Link() for i = 1 : 2];\n\njulia> connect(ls[1], ls[2])\n\njulia> findflow(ls[2], ls[1]) .== (ls[1], ls[2])\n(true, true)\n\n\n\n\n\n","category":"method"},{"location":"manual/connections/link/#Jusdl.Connections.insert","page":"Links","title":"Jusdl.Connections.insert","text":"insert(master::Link, slave::Link, new::Link)\n\nInserts the new link between the master link and slave link. The master is connected to new, and new is connected to slave.\n\nExample\n\njulia> ls = [Link() for i = 1 : 3];  \n\njulia> connect(ls[1], ls[2]) \n\njulia> insert(ls[1], ls[2], ls[3])\n\njulia> isconnected(ls[1], ls[2])\nfalse\n\njulia> isconnected(ls[1], ls[3]) && isconnected(ls[3], ls[2])\ntrue\n\n\n\n\n\n","category":"function"},{"location":"manual/connections/link/#Jusdl.Connections.release","page":"Links","title":"Jusdl.Connections.release","text":"release(link::Link)\n\nRelease all the slave links of link. That is, all the slave links of link is disconnected.\n\nExample\n\njulia> ls = [Link() for i = 1 : 5];\n\njulia> foreach(l -> connect(ls[1], l), ls[2:5])\n\njulia> map(l -> isconnected(ls[1], l), ls[2:5])\n4-element Array{Bool,1}:\n 1\n 1\n 1\n 1\n\njulia> release(ls[1])  # Release all the slaves.\n\njulia> map(l -> isconnected(ls[1], l), ls[2:5])\n4-element Array{Bool,1}:\n 0\n 0\n 0\n 0\n\n\n\n\n\nrelease(model::Model)\n\nReleaes the each component of model, i.e., the input and output bus of each component is released.\n\n\n\n\n\nrelease(comp::AbstractComponent)\n\nReleases the input and output bus of comp.\n\n\n\n\n\nrelease(comp::AbstractSubSystem)\n\nReleases comp by releasing each subcomponent of comp. See also: release(comp::AbstractComponent)\n\n\n\n\n\n","category":"function"},{"location":"manual/connections/link/#Base.bind","page":"Links","title":"Base.bind","text":"bind(link::Link, task::Task)\n\nBinds task to link. When task is done link is closed.\n\n\n\n\n\n","category":"function"},{"location":"manual/connections/link/#Base.collect-Tuple{Link}","page":"Links","title":"Base.collect","text":"collect(link::Link)\n\nCollects all the available data on the link.\n\n\n\n\n\n","category":"method"},{"location":"manual/connections/link/#Jusdl.Connections.launch-Tuple{Link}","page":"Links","title":"Jusdl.Connections.launch","text":"launch(link::Link)\n\nConstructs a taker task and binds it to link. The taker task reads the data and prints an info message until missing is read from the link.\n\n\n\n\n\n","category":"method"},{"location":"manual/connections/link/#Jusdl.Connections.launch-Tuple{Link,Any}","page":"Links","title":"Jusdl.Connections.launch","text":"launch(link:Link, valrange)\n\nConstructs a putter task and binds it to link. putter tasks puts the data in valrange.\n\n\n\n\n\n","category":"method"},{"location":"manual/utilities/callback/#Callback-1","page":"Callback","title":"Callback","text":"","category":"section"},{"location":"manual/utilities/callback/#","page":"Callback","title":"Callback","text":"DocTestSetup  = quote\n    using Jusdl\nend","category":"page"},{"location":"manual/utilities/callback/#","page":"Callback","title":"Callback","text":"Callbacks are used to monitor the existence of a specific events and if that specific event occurs, some other special jobs are invoked. Callbacks are intended to provide additional monitoring capability to any user-defined composite types. As such, Callbacks are generaly fields of user defined composite types objects. When a Callback is called, if the Callback is enabled and its condition function returns true, then its action function is invoked. ","category":"page"},{"location":"manual/utilities/callback/#A-Simple-Example-1","page":"Callback","title":"A Simple Example","text":"","category":"section"},{"location":"manual/utilities/callback/#","page":"Callback","title":"Callback","text":"Let's define a test object first that has a field named x of type Int and named callback of type Callback. ","category":"page"},{"location":"manual/utilities/callback/#","page":"Callback","title":"Callback","text":"julia> mutable struct TestObject\n       x::Int\n       callback::Callback\n       end","category":"page"},{"location":"manual/utilities/callback/#","page":"Callback","title":"Callback","text":"To construct an instance of TestObject, we need to construct a Callback. For that purpose, condition and action function must be defined. For this example, condition checks whether the x field is positive, and action prints a simple message saying that the x field is positive.","category":"page"},{"location":"manual/utilities/callback/#","page":"Callback","title":"Callback","text":"julia> condition(testobject) = testobject.x > 0 \ncondition (generic function with 1 method)\n\njulia> action(testobject) = println(\"testobject.x is greater than zero\") \naction (generic function with 1 method)","category":"page"},{"location":"manual/utilities/callback/#","page":"Callback","title":"Callback","text":"Now a test object can be constructed","category":"page"},{"location":"manual/utilities/callback/#","page":"Callback","title":"Callback","text":"julia> testobject = TestObject(-1, Callback(condition, action))  \nTestObject(-1, Callback{typeof(condition),typeof(action)}(condition, action, true, \"dac6f9eb-6daa-4622-a8fa-623f0f88780c\"))","category":"page"},{"location":"manual/utilities/callback/#","page":"Callback","title":"Callback","text":"If the callback is called, no action is performed since the condition function returns false. Note the argument sent to the callback. The instance of the TestObject to which the callback is a bound.","category":"page"},{"location":"manual/utilities/callback/#","page":"Callback","title":"Callback","text":"julia> testobject.callback(testobject) ","category":"page"},{"location":"manual/utilities/callback/#","page":"Callback","title":"Callback","text":"Now mutate the test object so that condition returns true.","category":"page"},{"location":"manual/utilities/callback/#","page":"Callback","title":"Callback","text":"julia> testobject.x = 3   \n3","category":"page"},{"location":"manual/utilities/callback/#","page":"Callback","title":"Callback","text":"Now, if the callback is called, since the condition returns true and the callback is enabled, the action is invoked.","category":"page"},{"location":"manual/utilities/callback/#","page":"Callback","title":"Callback","text":"julia> testobject.callback(testobject) \ntestobject.x is greater than zero","category":"page"},{"location":"manual/utilities/callback/#Full-API-1","page":"Callback","title":"Full API","text":"","category":"section"},{"location":"manual/utilities/callback/#","page":"Callback","title":"Callback","text":"Callback\nenable!\ndisable!\nisenabled\naddcallback\ndeletecallback","category":"page"},{"location":"manual/utilities/callback/#Jusdl.Utilities.Callback","page":"Callback","title":"Jusdl.Utilities.Callback","text":"Callback(condition, action)\n\nConstructs a Callback from condition and action. The condition and action must be a single-argument functions. condition returns true if the condition it checks occurs, otherwise ite returns false. action is performs the specific action for which the Callback the callback is contructed. A Callback can be called by passing its single argument which is mostly bound to the Callback.\n\nExample\n\njulia> struct Object  # Define a dummy type.\n       x::Int \n       clb::Callback \n       end \n\njulia> cond(obj) = obj.x > 0  # Define callback condition.\ncond (generic function with 1 method)\n\njulia> action(obj) = println(\"Printing the object \", obj) # Define callback action.\naction (generic function with 1 method)\n\njulia> obj = Object(1, Callback(cond, action))  # Construct an `Object` instance with `Callback`.\nObject(1, Callback(condition:cond, action:action))\n\njulia> obj.clb(obj)  # Call the callback bound `obj`.\nPrinting the object Object(1, Callback(condition:cond, action:action))\n\n\n\n\n\n","category":"type"},{"location":"manual/utilities/callback/#Jusdl.Utilities.enable!","page":"Callback","title":"Jusdl.Utilities.enable!","text":"enable!(clb::Callback)\n\nEnables clb.\n\n\n\n\n\n","category":"function"},{"location":"manual/utilities/callback/#Jusdl.Utilities.disable!","page":"Callback","title":"Jusdl.Utilities.disable!","text":"disable!(clb::Callback)\n\nDisables clb.\n\n\n\n\n\n","category":"function"},{"location":"manual/utilities/callback/#Jusdl.Utilities.isenabled","page":"Callback","title":"Jusdl.Utilities.isenabled","text":"isenabled(clb::Callback)\n\nReturns true if clb is enabled. Otherwise, returns false.\n\n\n\n\n\n","category":"function"},{"location":"manual/utilities/callback/#Jusdl.Utilities.addcallback","page":"Callback","title":"Jusdl.Utilities.addcallback","text":"addcallback(obj, clb::Callback, priority::Int)\n\nAdds clb to callback vector of obj which is assumed the have a callback list which is a vector of callback.\n\nExample\n\njulia> mutable struct Object \n       x::Int \n       callbacks::Vector{Callback}\n       Object(x::Int) = new(x, Callback[])\n       end \n\njulia> obj = Object(5)\nObject(5, Callback[])\n\njulia> condition(val) = val.x == 5\ncondition (generic function with 1 method)\n\njulia> action(val) = @show val.x \naction (generic function with 1 method)\n\njulia> addcallback(obj, Callback(condition, action))\nObject(5, Callback[Callback(condition:condition, action:action)])\n\njulia> obj.callbacks(obj)\nval.x = 5\n\n\n\n\n\n","category":"function"},{"location":"manual/utilities/callback/#Jusdl.Utilities.deletecallback","page":"Callback","title":"Jusdl.Utilities.deletecallback","text":"deletecallback(obj, idx::Int)\n\nDeletes the one of the callbacks of obj at index idx.\n\njulia> struct Object \n       x::Int \n       callbacks::Vector{Callback}\n       end\n\njulia> clb1 = Callback(val -> true, val -> nothing);\n\njulia> clb2 = Callback(val -> false, val -> nothing);\n\njulia> obj = Object(5, [clb1, clb2]);\n\njulia> deletecallback(obj, 2);\n\njulia> length(obj.callbacks) == 1\ntrue\n\n\n\n\n\n","category":"function"},{"location":"manual/connections/bus/#Busses-1","page":"Busses","title":"Busses","text":"","category":"section"},{"location":"manual/connections/bus/#","page":"Busses","title":"Busses","text":"A Bus is actually is a bunch of links. Reading from and writing into  data is performed as in the case of Links.","category":"page"},{"location":"manual/connections/bus/#Construction-of-Bus-1","page":"Busses","title":"Construction of Bus","text":"","category":"section"},{"location":"manual/connections/bus/#","page":"Busses","title":"Busses","text":"A Bus is constructed by specifying its element type T, number of links nlinks and the buffer length of its links.","category":"page"},{"location":"manual/connections/bus/#","page":"Busses","title":"Busses","text":"Bus","category":"page"},{"location":"manual/connections/bus/#Jusdl.Connections.Bus","page":"Busses","title":"Jusdl.Connections.Bus","text":"Bus{T}([nlinks::Int=1, [ln::Int=64]]) where T\n\nConstructs a Bus consisting of nlinks links. ln is the buffer length and T is element type of the links.\n\n\n\n\n\n","category":"type"},{"location":"manual/connections/bus/#Connection-and-Disconnection-of-Busses-1","page":"Busses","title":"Connection and Disconnection of Busses","text":"","category":"section"},{"location":"manual/connections/bus/#","page":"Busses","title":"Busses","text":"The Busses can be connected and disconnected to each other. When connected any data written to the master bus is also written all slave busses. See the following example.","category":"page"},{"location":"manual/connections/bus/#","page":"Busses","title":"Busses","text":"Let us connect two busses and connect them together.","category":"page"},{"location":"manual/connections/bus/#","page":"Busses","title":"Busses","text":"using Jusdl # hide\nb1 = Bus(2, 5)  # Bus with `2` links with buffer length of `5`.\nb2 = Bus(2, 5)  # Bus with `2` links with buffer length of `5`.\nconnect(b1, b2)","category":"page"},{"location":"manual/connections/bus/#","page":"Busses","title":"Busses","text":"Here, b1 is the master bus and b2 is the slave bus. That is, data written to b1 is also written into b2.","category":"page"},{"location":"manual/connections/bus/#","page":"Busses","title":"Busses","text":"t1 = launch(b1);\nt2 = launch(b2);\nput!(b1, [5., 10.]);\n[b1[i].buffer.data for i = 1 : 2]\n[b2[i].buffer.data for i = 1 : 2]","category":"page"},{"location":"manual/connections/bus/#","page":"Busses","title":"Busses","text":"Note that the data [5, 10] written to b1 is also written b2 since they are connected.","category":"page"},{"location":"manual/connections/bus/#","page":"Busses","title":"Busses","text":"The Busses connected to each other can be disconnected. When disconnected, the data written to master is not written to slaves","category":"page"},{"location":"manual/connections/bus/#","page":"Busses","title":"Busses","text":"disconnect(b1, b2)\nisconnected(b1, b2)","category":"page"},{"location":"manual/connections/bus/#Data-Flow-through-Busses-1","page":"Busses","title":"Data Flow through Busses","text":"","category":"section"},{"location":"manual/connections/bus/#","page":"Busses","title":"Busses","text":"Data flow through the Busses is very similar to the case in Links. See Data Flow through Links for information about data flow through Links. Runnable tasks must be bound to the links of the busses for data flow through the Bus. Again, put! and take! functions are used to write data from a Bus and read from data from a Bus.","category":"page"},{"location":"manual/connections/bus/#","page":"Busses","title":"Busses","text":"Connections.put!(bus::Bus, vals)\nConnections.take!(bus::Bus)","category":"page"},{"location":"manual/connections/bus/#Base.put!-Tuple{Bus,Any}","page":"Busses","title":"Base.put!","text":"put!(bus::Bus, vals)\n\nPuts vals to bus. Each item in vals is putted to the links of the bus.\n\nwarning: Warning\nThe bus must be writable to be read. That is, there must be a runnable tasks bound to links of the bus that reads data from bus.\n\n\n\n\n\n","category":"method"},{"location":"manual/connections/bus/#Base.take!-Tuple{Bus}","page":"Busses","title":"Base.take!","text":"take!(bus::Bus)\n\nTakes an element from bus. Each link of the bus is a read and a vector containing the results is returned.\n\nwarning: Warning\nThe bus must be readable to be read. That is, there must be a runnable tasks bound to links of the bus that writes data to bus.\n\n\n\n\n\n","category":"method"},{"location":"manual/connections/bus/#","page":"Busses","title":"Busses","text":"Any data written to a Bus is recorded into the buffers of its links.","category":"page"},{"location":"manual/connections/bus/#","page":"Busses","title":"Busses","text":"@repl writing_to_busses\nusing Jusdl # hide\nb = Bus(2, 5);\nlaunch(b);\nput!(b, 1.);\nb[1].buffer.data","category":"page"},{"location":"manual/connections/bus/#Indexing-and-Iteration-of-Busses-1","page":"Busses","title":"Indexing and Iteration of Busses","text":"","category":"section"},{"location":"manual/connections/bus/#","page":"Busses","title":"Busses","text":"Busses can be indexed similarly to the arrays in Julia. When indexed, corresponding link of the bus is returned.","category":"page"},{"location":"manual/connections/bus/#","page":"Busses","title":"Busses","text":"using Jusdl # hide \nb = Bus(3) \nb[1]\nb[end] \nb[:]\nb[1] = Link()\nb[1:2] = [Link(), Link()]","category":"page"},{"location":"manual/connections/bus/#","page":"Busses","title":"Busses","text":"The iteration of Busses in a loop is also possible. When iterated, the links of the Bus is returned.","category":"page"},{"location":"manual/connections/bus/#","page":"Busses","title":"Busses","text":"using Jusdl # hide \nbus = Bus(3)\nfor link in bus\n    @show link\nend","category":"page"},{"location":"manual/connections/bus/#Full-API-1","page":"Busses","title":"Full API","text":"","category":"section"},{"location":"manual/connections/bus/#","page":"Busses","title":"Busses","text":"Connections.eltype\nConnections.length\nConnections.iterate\nConnections.hasslaves(bus::Bus)\nConnections.hasmaster(bus::Bus)\nConnections.close(bus::Bus)\nConnections.isfull(bus::Bus)\nConnections.isreadable(bus::Bus)\nConnections.iswritable(bus::Bus)\nConnections.snapshot(bus::Bus)\nConnections.launch(bus::Bus)\nConnections.launch(bus::Bus, valrange::AbstractVector)\nConnections.getindex\nConnections.setindex!","category":"page"},{"location":"manual/connections/bus/#Base.eltype","page":"Busses","title":"Base.eltype","text":"eltype(link::Link)\n\nReturns element type of link.\n\n\n\n\n\n","category":"function"},{"location":"manual/connections/bus/#Base.iterate","page":"Busses","title":"Base.iterate","text":"iterate(clk::Clock[, t=clk.t)\n\nIterationk interface for clk. clk can be iterated in a loop.\n\nExample\n\njulia> clk = Clock(0., 0.1, 0.3);\n\njulia> set!(clk)\nClock(t:0.0, dt:0.1, tf:0.3, paused:false, isrunning:true)\n\njulia> for t in clk\n       @show t \n       end\nt = 0.0\nt = 0.1\nt = 0.2\nt = 0.3\n\n\n\n\n\n","category":"function"},{"location":"manual/connections/bus/#Jusdl.Connections.hasslaves-Tuple{Bus}","page":"Busses","title":"Jusdl.Connections.hasslaves","text":"hasslaves(bus:Bus)\n\nReturns true is all the links of bus has slaves. See also hasslaves(link::Link)\n\n\n\n\n\n","category":"method"},{"location":"manual/connections/bus/#Jusdl.Connections.hasmaster-Tuple{Bus}","page":"Busses","title":"Jusdl.Connections.hasmaster","text":"hasmaster(bus::Bus) \n\nReturns true is all the links of bus has master. See alsos hasmaster(link::Link)\n\n\n\n\n\n","category":"method"},{"location":"manual/connections/bus/#Base.close-Tuple{Bus}","page":"Busses","title":"Base.close","text":"close(bus::Bus)\n\nCloses bus. When closed, no more data flow is possible for bus. \n\n\n\n\n\n","category":"method"},{"location":"manual/connections/bus/#Jusdl.Connections.isfull-Tuple{Bus}","page":"Busses","title":"Jusdl.Connections.isfull","text":"isfull(bus::Bus)\n\nReturns true when the links of bus are full.\n\n\n\n\n\n","category":"method"},{"location":"manual/connections/bus/#Base.isreadable-Tuple{Bus}","page":"Busses","title":"Base.isreadable","text":"isreadable(bus::Bus)\n\nReturns true if all the links of bus is readable.\n\n\n\n\n\n","category":"method"},{"location":"manual/connections/bus/#Base.iswritable-Tuple{Bus}","page":"Busses","title":"Base.iswritable","text":"iswritable(bus::Bus)\n\nReturns true if all the links of bus is writable.\n\n\n\n\n\n","category":"method"},{"location":"manual/connections/bus/#Jusdl.Connections.snapshot-Tuple{Bus}","page":"Busses","title":"Jusdl.Connections.snapshot","text":"snapshot(bus::Bus)\n\nReturns all the data in links of bus.\n\n\n\n\n\n","category":"method"},{"location":"manual/connections/bus/#Jusdl.Connections.launch-Tuple{Bus}","page":"Busses","title":"Jusdl.Connections.launch","text":"launch(bus::Bus)\n\nLaunches every link of bus. See launch(link::Link)\n\n\n\n\n\n","category":"method"},{"location":"manual/connections/bus/#Jusdl.Connections.launch-Tuple{Bus,AbstractArray{T,1} where T}","page":"Busses","title":"Jusdl.Connections.launch","text":"launch(bus::Bus, valrange::AbstractVector)\n\nLaunches every links of bus with every item of valrange. See [launch(link:Link, valrange)(@ref)]\n\n\n\n\n\n","category":"method"},{"location":"manual/connections/bus/#Base.getindex","page":"Busses","title":"Base.getindex","text":"getindex(bus::Bus, idx::Vararg{Int, N}) where N\n\nReturns elements from bus at index idx.\n\n\n\n\n\ngetindex(buf::Buffer, idx::Vararg{Int, N})\n\nReturns an element from buf at index idx. Same as buf[idx] ```\n\n\n\n\n\n","category":"function"},{"location":"manual/connections/bus/#Base.setindex!","page":"Busses","title":"Base.setindex!","text":"setindex!(bus::Bus, item, idx::Vararg{Int, N}) where N\n\nSets item to bus at index idx.\n\n\n\n\n\nsetindex!(buf::Buffer, val, idx)\n\nSets val to buf at index idx. Same as buf[idx] = val.\n\n\n\n\n\n","category":"function"},{"location":"manual/components/sources/generators/#Generators-1","page":"Generators","title":"Generators","text":"","category":"section"},{"location":"manual/components/sources/generators/#FunctionGenerator-1","page":"Generators","title":"FunctionGenerator","text":"","category":"section"},{"location":"manual/components/sources/generators/#","page":"Generators","title":"Generators","text":"`FunctionGenerator is the generic function generator. The output waveform is shaped by its output function. A FunctionGenerator can be construted by specifying its output function outputfunc.","category":"page"},{"location":"manual/components/sources/generators/#","page":"Generators","title":"Generators","text":"FunctionGenerator","category":"page"},{"location":"manual/components/sources/generators/#Jusdl.Components.Sources.FunctionGenerator","page":"Generators","title":"Jusdl.Components.Sources.FunctionGenerator","text":"FunctionGenerator(outputfunc)\n\nConstructs a FunctionGenerator with the output of the form x(t) = f(t) where f is outputfunc.\n\n\n\n\n\n","category":"type"},{"location":"manual/components/sources/generators/#Basic-Operation-AbstractSource-1","page":"Generators","title":"Basic Operation AbstractSource","text":"","category":"section"},{"location":"manual/components/sources/generators/#","page":"Generators","title":"Generators","text":"AnAbstractSource is a subtype of AbstractComponent. (See Components for more information.) An AbstractComponent has input and output for data flow. The AbstractComponent reads data from input and writes data to output. Since the input-output relation of AbstractSource depends on just the current time t, Sources does not have inputs since they do not read input values. They just need time t to compute its output. During their evolution, the AbstractComponent read time t from their trigger links, computes their output according to their output function and writes its computed output to their output busses. An AbstractComponent also writes true to their handshake links in signal that the evolution is succeeded. To further clarify the operation of AbstractSource, let us do some examples. ","category":"page"},{"location":"manual/components/sources/generators/#","page":"Generators","title":"Generators","text":"using Jusdl # hide \noutputfunc(t) = t * exp(t) + sin(t)\ngen = FunctionGenerator(outputfunc)","category":"page"},{"location":"manual/components/sources/generators/#","page":"Generators","title":"Generators","text":"We constructed a FunctionGenerator which is an AbstractSource.","category":"page"},{"location":"manual/components/sources/generators/#","page":"Generators","title":"Generators","text":"gen isa AbstractSource","category":"page"},{"location":"manual/components/sources/generators/#","page":"Generators","title":"Generators","text":"To drive gen, that is to make gen evolve, we need to launch gen. ","category":"page"},{"location":"manual/components/sources/generators/#","page":"Generators","title":"Generators","text":"t = launch(gen)","category":"page"},{"location":"manual/components/sources/generators/#","page":"Generators","title":"Generators","text":"At this moment, gen is ready to be triggered from its trigger link. Note that the trigger link gen.trigger and the output gen.output of gen are writable. ","category":"page"},{"location":"manual/components/sources/generators/#","page":"Generators","title":"Generators","text":"gen.trigger\ngen.output","category":"page"},{"location":"manual/components/sources/generators/#","page":"Generators","title":"Generators","text":"gen is triggered by writing time t to its trigger link gen.trigger.","category":"page"},{"location":"manual/components/sources/generators/#","page":"Generators","title":"Generators","text":"put!(gen.trigger, 1.)","category":"page"},{"location":"manual/components/sources/generators/#","page":"Generators","title":"Generators","text":"When triggered gen writes true to its handshake link gen.handshake. Note that gen.handshake is readable.","category":"page"},{"location":"manual/components/sources/generators/#","page":"Generators","title":"Generators","text":"gen.handshake","category":"page"},{"location":"manual/components/sources/generators/#","page":"Generators","title":"Generators","text":"and to drive gen for another time gen.handshake must be read. ","category":"page"},{"location":"manual/components/sources/generators/#","page":"Generators","title":"Generators","text":"take!(gen.handshake)","category":"page"},{"location":"manual/components/sources/generators/#","page":"Generators","title":"Generators","text":"Now continue driving gen.","category":"page"},{"location":"manual/components/sources/generators/#","page":"Generators","title":"Generators","text":"for t in 2. : 10.\n    put!(gen.trigger, t)\n    take!(gen.handshake)\nend","category":"page"},{"location":"manual/components/sources/generators/#","page":"Generators","title":"Generators","text":"When triggered, the output of gen is written to its output gen.output.","category":"page"},{"location":"manual/components/sources/generators/#","page":"Generators","title":"Generators","text":"println(gen.output[1].buffer.data)","category":"page"},{"location":"manual/components/sources/generators/#","page":"Generators","title":"Generators","text":"In addition to generic FunctionGenerator, Jusdl provides some other function generators which are documented in the following section.","category":"page"},{"location":"manual/components/sources/generators/#Full-API-1","page":"Generators","title":"Full API","text":"","category":"section"},{"location":"manual/components/sources/generators/#","page":"Generators","title":"Generators","text":"SinewaveGenerator\nDampedSinewaveGenerator\nSquarewaveGenerator\nTriangularwaveGenerator\nConstantGenerator\nRampGenerator\nStepGenerator\nExponentialGenerator\nDampedExponentialGenerator","category":"page"},{"location":"manual/components/sources/generators/#Jusdl.Components.Sources.SinewaveGenerator","page":"Generators","title":"Jusdl.Components.Sources.SinewaveGenerator","text":"SinewaveGenerator(;amplitude=1., frequency=1., phase=0., delay=0., offset=0.)\n\nConstructs a SinewaveGenerator with output of the form\n\n    x(t) = A sin(2 pi f  (t - tau) + phi) + B\n\nwhere A is amplitude, f is frequency, tau is delay and phi is phase and B is offset.\n\n\n\n\n\n","category":"type"},{"location":"manual/components/sources/generators/#Jusdl.Components.Sources.DampedSinewaveGenerator","page":"Generators","title":"Jusdl.Components.Sources.DampedSinewaveGenerator","text":"DampedSinewaveGenerator(;amplitude=1., decay=-0.5, frequency=1., phase=0., delay=0., offset=0.)\n\nConstructs a DampedSinewaveGenerator which generates outputs of the form \n\n    x(t) = A e^alpha t * sin(2 pi f (t - tau) + phi) + B\n\nwhere A is amplitude, alpha is decay, f is frequency, phi is phase, tau is delay and B is offset.\n\n\n\n\n\n","category":"type"},{"location":"manual/components/sources/generators/#Jusdl.Components.Sources.SquarewaveGenerator","page":"Generators","title":"Jusdl.Components.Sources.SquarewaveGenerator","text":"SquarewaveGenerator(;level1=1., level2=0., period=1., duty=0.5, delay=0.)\n\nConstructs a SquarewaveGenerator with output of the form \n\n    x(t) = leftbeginarraylr\n\tA_1 + B   kT + tau leq t leq (k + alpha) T + tau \n\tA_2 + B    (k + alpha) T + tau leq t leq (k + 1) T + tau\t\n\tendarray right quad k in Z\n\nwhere A_1, A_2 is level1 and level2, T is period, tau is delay alpha is duty. \n\n\n\n\n\n","category":"type"},{"location":"manual/components/sources/generators/#Jusdl.Components.Sources.TriangularwaveGenerator","page":"Generators","title":"Jusdl.Components.Sources.TriangularwaveGenerator","text":"TriangularwaveGenerator(;amplitude=1, period=1, duty=0.5, delay=0, offset=0)\n\nConstructs a TriangularwaveGenerator with output of the form\n\n    x(t) = leftbeginarraylr\n\tdfracA talpha T + B   kT + tau leq t leq (k + alpha) T + tau 025cm\n\tdfracA (T - t)T (1 - alpha) + B    (k + alpha) T + tau leq t leq (k + 1) T + tau\t\n\tendarray right quad k in Z\n\nwhere A is amplitude, T is period, tau is delay alpha is duty. \n\n\n\n\n\n","category":"type"},{"location":"manual/components/sources/generators/#Jusdl.Components.Sources.ConstantGenerator","page":"Generators","title":"Jusdl.Components.Sources.ConstantGenerator","text":"ConstantGenerator(;amplitude=1.)\n\nConstructs a Constructs with output of the form\n\n    x(t) = A\n\nwhere A is `amplitude.\n\n\n\n\n\n","category":"type"},{"location":"manual/components/sources/generators/#Jusdl.Components.Sources.RampGenerator","page":"Generators","title":"Jusdl.Components.Sources.RampGenerator","text":"RampGenerator(;scale=1)\n\nConstructs a RampGenerator with output of the form\n\n    x(t) = alpha t\n\nwhere alpha is the scale.\n\n\n\n\n\n","category":"type"},{"location":"manual/components/sources/generators/#Jusdl.Components.Sources.StepGenerator","page":"Generators","title":"Jusdl.Components.Sources.StepGenerator","text":"StepGenerator(;amplitude=1, delay=0, offset=0)\n\nConstructs a StepGenerator with output of the form \n\n    x(t) = leftbeginarraylr\n\tB   t leq 0  \n\tA + B    t  0\n\tendarray right\n\n\n\n\n\n","category":"type"},{"location":"manual/components/sources/generators/#Jusdl.Components.Sources.ExponentialGenerator","page":"Generators","title":"Jusdl.Components.Sources.ExponentialGenerator","text":"ExponentialGenerator(;scale=1, decay=-1)\n\nConstructs an ExponentialGenerator with output of the form\n\n    x(t) = A e^alpha t\n\nwhere A is scale, alpha is decay.\n\n\n\n\n\n","category":"type"},{"location":"manual/components/sources/generators/#Jusdl.Components.Sources.DampedExponentialGenerator","page":"Generators","title":"Jusdl.Components.Sources.DampedExponentialGenerator","text":"DampedExponentialGenerator(;scale=1, decay=-1)\n\nConstructs an DampedExponentialGenerator with outpsuts of the form \n\n    x(t) = A t e^alpha t\n\nwhere A is scale, alpha is decay.\n\n\n\n\n\n","category":"type"},{"location":"manual/models/taskmanager/#Task-Manager-1","page":"Task Manager","title":"Task Manager","text":"","category":"section"},{"location":"manual/models/taskmanager/#","page":"Task Manager","title":"Task Manager","text":"A TaskManager is actually the pairs of components and the tasks constructed corresponding to those components. In Jusdl, models are simulated by individually evolving the components. This individual evolution of components is performed by defining components individually and constructing tasks for each components. The jobs that are defined in these tasks are defined to make the components evolve by reading its time, input, compute its output. During this evolution, the tasks may fail because any inconsistency. Right after the failure of a task, its not possible for the component corresponding to the task to evolve any more. As the data flows through the components that connects the components, model simulation gets stuck. To keep track of the task launched for each component, a TaskManager is used. Before starting to simulate a model, a TaskManager is constructed for the model components. During the initialization of simulation, tasks corresponding to the components of the model is launched and the pair of component and component task is recorded in the TaskManager of the model. During the run stage of the simulation, TaskManager keeps track of the component tasks. In case any failure in components tasks, the cause of the failure can be investigated with TaskManager.","category":"page"},{"location":"manual/models/taskmanager/#Full-API-1","page":"Task Manager","title":"Full API","text":"","category":"section"},{"location":"manual/models/taskmanager/#","page":"Task Manager","title":"Task Manager","text":"ComponentTask\nTaskManager\nchecktaskmanager\nistaskfailed\nistaskrunning \nistaskdone","category":"page"},{"location":"manual/models/taskmanager/#Jusdl.Models.ComponentTask","page":"Task Manager","title":"Jusdl.Models.ComponentTask","text":"ComponentTask(triggertask, outputtask)\n\nConstructs a ComponentTask from triggertask and outputtask. triggertask is the task constructed for the evolution of components and outputtask task is contructed to make the output busses of the components writable. \n\nExample\n\njulia> gen = SinewaveGenerator()\nSinewaveGenerator(amp:1.0, freq:1.0, phase:0.0, offset:0.0, delay:0.0)\n\njulia> taskpair = launch(gen)\n(Task (runnable) @0x00007f4de65544f0, Task (runnable) @0x00007f4de5e8fd00)\n\njulia> comptask = ComponentTask(taskpair)\nComponentTask{Task,Task}(Task (runnable) @0x00007f4de65544f0, Task (runnable) @0x00007f4de5e8fd00)\n\n\n\n\n\n","category":"type"},{"location":"manual/models/taskmanager/#Jusdl.Models.TaskManager","page":"Task Manager","title":"Jusdl.Models.TaskManager","text":"TaskManager(pairs)\n\nConstructs a TaskManager with pairs. pairs is a dictionary whose keys are components and values are component tasks. Component tasks are constructed correponding to the components. A TaskManager is used to keep track of the component task launched corresponding to components.\n\nTaskManager()\n\nConstructs a TaskManager with empty `pairs.\n\nExample\n\njulia> tm = TaskManager()  # A TaskManager with empty pairs\nTaskManager(pairs:Dict{Any,Any}())\n\njulia> gen = SinewaveGenerator()  # A component\nSinewaveGenerator(amp:1.0, freq:1.0, phase:0.0, offset:0.0, delay:0.0)\n\njulia> ct = ComponentTask(launch(gen))  # A component task corresponding to gen\nComponentTask{Task,Task}(Task (runnable) @0x00007f4de1a0d390, Task (runnable) @0x00007f4de1a0d120)\n\njulia> tm.pairs[gen] = ct  # Write a component and compontent task pair into TaskManager\nComponentTask{Task,Task}(Task (runnable) @0x00007f4de1a0d390, Task (runnable) @0x00007f4de1a0d120)\n\njulia> println(tm.pairs)\nDict{Any,Any}(SinewaveGenerator(amp:1.0, freq:1.0, phase:0.0, offset:0.0, delay:0.0) => ComponentTask{Task,Task}(Task (runnable) @0x00007f4de1a0d390, Task (runnable) @0x00007f4de1a0d120))\n\n\n\n\n\n","category":"type"},{"location":"manual/models/taskmanager/#Jusdl.Models.checktaskmanager","page":"Task Manager","title":"Jusdl.Models.checktaskmanager","text":"checktaskmanager(tm::TaskManager)\n\nThrows an error if any of the component task of tm is failed. See also: TaskManager\n\n\n\n\n\n","category":"function"},{"location":"manual/models/taskmanager/#Base.istaskfailed","page":"Task Manager","title":"Base.istaskfailed","text":"istaskfailed(task::Nothing)\n\nReturns false.\n\nistaskfailed(comptask::ComponentTask)\n\nReturns true is triggertask or outputtask of comptask is failed. See also: ComponentTask\n\n\n\n\n\n","category":"function"},{"location":"manual/models/taskmanager/#Jusdl.Models.istaskrunning","page":"Task Manager","title":"Jusdl.Models.istaskrunning","text":"istaskrunning(task::Task)\n\nReturns true is the state of task is runnable. \n\nistaskrunning(task::Nothing)\n\nReturns true\n\nistaskrunning(comptask::ComponentTask)\n\nReturns true if triggertask and outputtask of comptask is running. See also: ComponentTask\n\n\n\n\n\n","category":"function"},{"location":"manual/models/taskmanager/#Base.istaskdone","page":"Task Manager","title":"Base.istaskdone","text":"istaskrunning(task::Nothing)\n\nReturns true \n\nistaskdone(comptask::ComponentTask)\n\nReturns true if the state of triggertask and outputtask of comptask is done. See also: ComponentTask\n\n\n\n\n\n","category":"function"},{"location":"manual/components/componentsbase/generic_fields/#Generic-Fields-of-Components-1","page":"Generic Fields of Components","title":"Generic Fields of Components","text":"","category":"section"},{"location":"manual/components/componentsbase/generic_fields/#","page":"Generic Fields of Components","title":"Generic Fields of Components","text":"To be written ...","category":"page"},{"location":"manual/components/componentsbase/evolution/#Evolution-of-Components-1","page":"Evolution of Components","title":"Evolution of Components","text":"","category":"section"},{"location":"manual/components/componentsbase/evolution/#Reading-Time-1","page":"Evolution of Components","title":"Reading Time","text":"","category":"section"},{"location":"manual/components/componentsbase/evolution/#","page":"Evolution of Components","title":"Evolution of Components","text":"readtime","category":"page"},{"location":"manual/components/componentsbase/evolution/#Jusdl.Components.ComponentsBase.readtime","page":"Evolution of Components","title":"Jusdl.Components.ComponentsBase.readtime","text":"readtime(comp::AbstractComponent)\n\nReturns current time of comp from its trigger link.\n\nnote: Note\nTo read time of comp, comp must be launched. See also: launch(comp::AbstractComponent).\n\n\n\n\n\n","category":"function"},{"location":"manual/components/componentsbase/evolution/#Reading-State-1","page":"Evolution of Components","title":"Reading State","text":"","category":"section"},{"location":"manual/components/componentsbase/evolution/#","page":"Evolution of Components","title":"Evolution of Components","text":"readstate","category":"page"},{"location":"manual/components/componentsbase/evolution/#Jusdl.Components.ComponentsBase.readstate","page":"Evolution of Components","title":"Jusdl.Components.ComponentsBase.readstate","text":"readstate(comp::AbstractComponent)\n\nReturns the state of comp if comp is AbstractDynamicSystem. Otherwise, returns nothing. \n\n\n\n\n\n","category":"function"},{"location":"manual/components/componentsbase/evolution/#Reading-Input-1","page":"Evolution of Components","title":"Reading Input","text":"","category":"section"},{"location":"manual/components/componentsbase/evolution/#","page":"Evolution of Components","title":"Evolution of Components","text":"readinput","category":"page"},{"location":"manual/components/componentsbase/evolution/#Jusdl.Components.ComponentsBase.readinput","page":"Evolution of Components","title":"Jusdl.Components.ComponentsBase.readinput","text":"readinput(comp::AbstractComponent)\n\nReturne the input value of comp if the input of comp is Bus. Otherwise, returns nothing.\n\nnote: Note\nTo read input value of comp, comp must be launched. See also: launch(comp::AbstractComponent)\n\n\n\n\n\n","category":"function"},{"location":"manual/components/componentsbase/evolution/#Writing-Output-1","page":"Evolution of Components","title":"Writing Output","text":"","category":"section"},{"location":"manual/components/componentsbase/evolution/#","page":"Evolution of Components","title":"Evolution of Components","text":"writeoutput","category":"page"},{"location":"manual/components/componentsbase/evolution/#Jusdl.Components.ComponentsBase.writeoutput","page":"Evolution of Components","title":"Jusdl.Components.ComponentsBase.writeoutput","text":"writeoutput(comp::AbstractComponent, out)\n\nWrites out to the output of comp if the output of comp is Bus. Otherwise, does nothing.\n\n\n\n\n\n","category":"function"},{"location":"manual/components/componentsbase/evolution/#Computing-Output-1","page":"Evolution of Components","title":"Computing Output","text":"","category":"section"},{"location":"manual/components/componentsbase/evolution/#","page":"Evolution of Components","title":"Evolution of Components","text":"computeoutput ","category":"page"},{"location":"manual/components/componentsbase/evolution/#Jusdl.Components.ComponentsBase.computeoutput","page":"Evolution of Components","title":"Jusdl.Components.ComponentsBase.computeoutput","text":"computeoutput(comp, x, u, t)\n\nComputes the output of comp according to its outputfunc if outputfunc is not nothing. Otherwise, nothing is done. x is the state, u is the value of input, t is the time. \n\n\n\n\n\n","category":"function"},{"location":"manual/components/componentsbase/evolution/#Evolve-1","page":"Evolution of Components","title":"Evolve","text":"","category":"section"},{"location":"manual/components/componentsbase/evolution/#","page":"Evolution of Components","title":"Evolution of Components","text":"evolve!\nupdate! ","category":"page"},{"location":"manual/components/componentsbase/evolution/#Jusdl.Components.ComponentsBase.evolve!","page":"Evolution of Components","title":"Jusdl.Components.ComponentsBase.evolve!","text":"evolve!(comp::AbstractSource, x, u, t)\n\nDoes nothing. x is the state, u is the value of input and t is time.\n\nevolve!(comp::AbstractSink, x, u, t)\n\nWrites t to time buffer timebuf and u to databuf of comp. x is the state, u is the value of input and t is time.\n\nevolve!(comp::AbstractStaticSystem, x, u, t)\n\nWrites u to buffer of comp if comp is an AbstractMemory. Otherwise, nothing is done. x is the state, u is the value of input and t is time. \n\nevolve!(comp::AbstractDynamicSystem, x, u, t)\n\nSolves the differential equaition of the system of comp for the time interval (comp.t, t) for the inital condition x. u is the input function defined for (comp.t, t). The comp is updated with the computed state and time t. See also: update!(comp::AbstractDynamicSystem, sol, u)\n\n\n\n\n\n","category":"function"},{"location":"manual/components/componentsbase/evolution/#Jusdl.Components.ComponentsBase.update!","page":"Evolution of Components","title":"Jusdl.Components.ComponentsBase.update!","text":"update!(comp::AbstractDynamicSystem, sol, u)\n\nUpdates comp with the differential equation solution sol and the input value u. The time t, state state and inputval is updated. Furthermore, stateder is also updated if comp isa AbstractDAESystem and noise is update if comp is AbstractSDESystem or AbstractRODESystem.\n\n\n\n\n\nupdate!(s::Scope, x, yi)\n\nUpdates the series of the plot windows of s with x and yi.\n\n\n\n\n\n","category":"function"},{"location":"manual/components/componentsbase/evolution/#Taking-Steps-1","page":"Evolution of Components","title":"Taking Steps","text":"","category":"section"},{"location":"manual/components/componentsbase/evolution/#","page":"Evolution of Components","title":"Evolution of Components","text":"takestep\nJusdl.Components.ComponentsBase.forwardstep\nJusdl.Components.ComponentsBase.backwardstep\nlaunch(comp::AbstractComponent)\nlaunch(comp::AbstractSubSystem)\ndrive\napprove\nrelease(comp::AbstractComponent)\nrelease(comp::AbstractSubSystem)\nterminate","category":"page"},{"location":"manual/components/componentsbase/evolution/#Jusdl.Components.ComponentsBase.takestep","page":"Evolution of Components","title":"Jusdl.Components.ComponentsBase.takestep","text":"takestep(comp::AbstractComponent)\n\nReads the time t from the trigger link of comp. If comp is an AbstractMemory, a backward step is taken. Otherwise, a forward step is taken. See also: forwardstep, backwardstep.\n\n\n\n\n\ntakestep(comp::AbstractSubSystem)\n\nMakes comp to take a step by making each subcomponent of comp take a step. See also: takestep(comp::AbstractComponent)\n\n\n\n\n\n","category":"function"},{"location":"manual/components/componentsbase/evolution/#Jusdl.Components.ComponentsBase.forwardstep","page":"Evolution of Components","title":"Jusdl.Components.ComponentsBase.forwardstep","text":"forwardstep(comp, t)\n\nMakes comp takes a forward step.  The input value u and state x of comp are read. Using x, u and time t,  comp is evolved. The output y of comp is computed and written into the output bus of comp. \n\n\n\n\n\n","category":"function"},{"location":"manual/components/componentsbase/evolution/#Jusdl.Components.ComponentsBase.backwardstep","page":"Evolution of Components","title":"Jusdl.Components.ComponentsBase.backwardstep","text":"backwardstep(comp, t)\n\nReads the state x. Using the time t and x, computes and writes the ouput value y of comp. Then, the input value u is read and comp is evolved.  \n\n\n\n\n\n","category":"function"},{"location":"manual/components/componentsbase/evolution/#Jusdl.Connections.launch-Tuple{AbstractComponent}","page":"Evolution of Components","title":"Jusdl.Connections.launch","text":"launch(comp::AbstractComponent)\n\nReturns a tuple of tasks so that trigger link and output bus of comp is drivable. When launched, comp is ready to be driven from its trigger link. See also: drive(comp::AbstractComponent, t)\n\n\n\n\n\n","category":"method"},{"location":"manual/components/componentsbase/evolution/#Jusdl.Connections.launch-Tuple{AbstractSubSystem}","page":"Evolution of Components","title":"Jusdl.Connections.launch","text":"launch(comp::AbstractSubSystem)\n\nLaunches all subcomponents of comp. See also: launch(comp::AbstractComponent)\n\n\n\n\n\n","category":"method"},{"location":"manual/components/componentsbase/evolution/#Jusdl.Components.ComponentsBase.drive","page":"Evolution of Components","title":"Jusdl.Components.ComponentsBase.drive","text":"drive(comp::AbstractComponent, t)\n\nWrites t to the trigger link of comp. When driven, comp takes a step. See also: takestep(comp::AbstractComponent)\n\n\n\n\n\ndrive(comp::AbstractSubSystem, t)\n\nDrives comp by driving each subcomponent of comp. See also: drive(comp::AbstractComponent, t)\n\n\n\n\n\n","category":"function"},{"location":"manual/components/componentsbase/evolution/#Jusdl.Components.ComponentsBase.approve","page":"Evolution of Components","title":"Jusdl.Components.ComponentsBase.approve","text":"approve(comp::AbstractComponent)\n\nRead handshake link of comp. When not approved or false is read from the handshake link, the task launched for the trigger link of comp gets stuck during comp is taking step.\n\n\n\n\n\napprove(comp::AbstractSubSystem)\n\nApproves comp by approving each subcomponent of comp. See also: approve(comp::AbstractComponent)\n\n\n\n\n\n","category":"function"},{"location":"manual/components/componentsbase/evolution/#Jusdl.Connections.release-Tuple{AbstractComponent}","page":"Evolution of Components","title":"Jusdl.Connections.release","text":"release(comp::AbstractComponent)\n\nReleases the input and output bus of comp.\n\n\n\n\n\n","category":"method"},{"location":"manual/components/componentsbase/evolution/#Jusdl.Connections.release-Tuple{AbstractSubSystem}","page":"Evolution of Components","title":"Jusdl.Connections.release","text":"release(comp::AbstractSubSystem)\n\nReleases comp by releasing each subcomponent of comp. See also: release(comp::AbstractComponent)\n\n\n\n\n\n","category":"method"},{"location":"manual/components/componentsbase/evolution/#Jusdl.Components.ComponentsBase.terminate","page":"Evolution of Components","title":"Jusdl.Components.ComponentsBase.terminate","text":"terminate(model::Model)\n\nTerminates model by terminating all the components of the model, i.e., the components tasks in the task manager of the model is terminated. See also: ComponentTask, TaskManager.\n\n\n\n\n\nterminate(comp::AbstractComponent)\n\nCloses the trigger link and output bus of comp.\n\n\n\n\n\nterminate(comp::AbstractSubSystem)\n\nTerminates comp by terminating each subcomponent of comp. See also: terminate(comp::AbstractComponent)\n\n\n\n\n\n","category":"function"},{"location":"manual/plugins/plugins/#Plugins-1","page":"Plugins","title":"Plugins","text":"","category":"section"},{"location":"manual/plugins/plugins/#","page":"Plugins","title":"Plugins","text":"Plugins are extensions that are used to process online the data flowing through the connections of the model during the simulation. Jusdl provides some simple Plugins such as Plugins.Lyapunov, Plugins.Fft, Plugins.Mean, Plugins.Std, Plugins.Variance. These tools are specialized tools that are used for specialized data processing. In addition to the plugins that are provided by Jusdl, it is also possible to write new plugins that focus on different specialized data processing. The fundamental importance of Plugins is that they the online simulation data processing possible. ","category":"page"},{"location":"manual/plugins/plugins/#","page":"Plugins","title":"Plugins","text":"The Plugins are mostly used with Sinks. In Jusdl, the Sinks are used to sink simulation data flowing through the connections of the model. When a Sink is equipped with a proper Plugin according to the data processing desired, then the data flowing into the Sink is processed. For example, consider that a Writer is equipped with a Lyapunov plugin. During the simulation, data flowing into the Writer is processed to compute the maximum Lyapnunov exponent, and this computed maximum Lyapunov exponents are recorded in the file of the Writer. Similarly, if a Printer is equipped with an Fft plugin, then Fast Fourier transform of the data flowing into the Printer is printed on the console.","category":"page"},{"location":"manual/plugins/plugins/#Data-processing-via-Plugins-1","page":"Plugins","title":"Data processing via Plugins","text":"","category":"section"},{"location":"manual/plugins/plugins/#","page":"Plugins","title":"Plugins","text":"Each Plugin must have a process function which does the data processing. The first argument of the process function is the Plugin and the second argument is the data to be processed. Here are some of the methods of process function","category":"page"},{"location":"manual/plugins/plugins/#","page":"Plugins","title":"Plugins","text":"process","category":"page"},{"location":"manual/plugins/plugins/#Jusdl.Plugins.process","page":"Plugins","title":"Jusdl.Plugins.process","text":"process(plg::Fft, x)\n\nPerformes an fft transformation for the input data x.\n\nExample\n\njulia> x = collect(reshape(1:16, 4,4))\n4×4 Array{Int64,2}:\n 1  5   9  13\n 2  6  10  14\n 3  7  11  15\n 4  8  12  16\n\njulia> plg = Plugins.Fft(dims=1)\nFft(dims:1)\n\njulia> process(plg, x)\n4×4 Array{Complex{Float64},2}:\n 10.0+0.0im  26.0+0.0im  42.0+0.0im  58.0+0.0im\n -2.0+2.0im  -2.0+2.0im  -2.0+2.0im  -2.0+2.0im\n -2.0+0.0im  -2.0+0.0im  -2.0+0.0im  -2.0+0.0im\n -2.0-2.0im  -2.0-2.0im  -2.0-2.0im  -2.0-2.0im\n\n\n\n\n\nprocess(plg::Lyapunov, x)\n\nComputes the maximum Lyapunov exponent of the input data x. \n\nExample\n\njulia> using Random \n\njulia> rng = MersenneTwister(1234);\n\njulia> x = rand(rng, 1000);\n\njulia> plg = Plugins.Lyapunov()\nLyapunov(embeddingdim:15, numlags:5, numiteration:300, samplingtime:0.01\n\njulia> process(plg, x)\n-0.42032928176193973\n\n\n\n\n\nprocess(plg::Mean, x)\n\nReturns the means of x along the dimension plg.dims.\n\nExample\n\njulia> x = collect(reshape(1:16, 4,4))\n4×4 Array{Int64,2}:\n 1  5   9  13\n 2  6  10  14\n 3  7  11  15\n 4  8  12  16\n\njulia> plg = Plugins.Mean(dims=1)\nMean(dims:1)\n\njulia> process(plg, x)\n1×4 Array{Float64,2}:\n 2.5  6.5  10.5  14.5\n\n\n\n\n\nprocess(plg::Std, x)\n\nReturns the standard deviation of x along the dimension plg.dims.\n\nExample\n\njulia> x = collect(reshape(1:16, 4,4))\n4×4 Array{Int64,2}:\n 1  5   9  13\n 2  6  10  14\n 3  7  11  15\n 4  8  12  16\n\njulia> plg = Plugins.Std(dims=1)\nMean(dims:1)\n\njulia> process(plg, x)\n1×4 Array{Float64,2}:\n 1.29099  1.29099  1.29099  1.29099\n\n\n\n\n\nprocess(plg::Std, x)\n\nReturns the standard deviation of x along the dimension plg.dims.\n\nExample\n\njulia> x = collect(reshape(1:16, 4,4))\n4×4 Array{Int64,2}:\n 1  5   9  13\n 2  6  10  14\n 3  7  11  15\n 4  8  12  16\n\njulia> plg = Plugins.Variance(dims=1)\nMean(dims:1)\n\njulia> process(plg, x)\n1×4 Array{Float64,2}:\n 1.66667  1.66667  1.66667  1.66667\n\n\n\n\n\n","category":"function"},{"location":"manual/plugins/plugins/#Defining-New-Plugins-1","page":"Plugins","title":"Defining New Plugins","text":"","category":"section"},{"location":"manual/plugins/plugins/#","page":"Plugins","title":"Plugins","text":"New plugins can be defined in Jusld and having they are defined properly they can work just expected. To define a new plugin, we must first define the plugin type ","category":"page"},{"location":"manual/plugins/plugins/#","page":"Plugins","title":"Plugins","text":"using Jusdl # hide \nimport Jusdl.Plugins.AbstractPlugin\nstruct NewPlugin <: AbstractPlugin\n    # Parameters of NewPlugin\nend","category":"page"},{"location":"manual/plugins/plugins/#","page":"Plugins","title":"Plugins","text":"warning: Warning\nNote that to the NewPlugin is defined to be a subtype of AbstractPlugin. This is important for the NewPlugin to work as expected.","category":"page"},{"location":"manual/plugins/plugins/#","page":"Plugins","title":"Plugins","text":"Since each plugin must have process method, Jusdl.Plugins.process function must be imported and dispatched.","category":"page"},{"location":"manual/plugins/plugins/#","page":"Plugins","title":"Plugins","text":"import Jusdl.Plugins.process\nfunction process(plg::NewTemplate, x)\n    # Define the process according to plg\nend","category":"page"},{"location":"manual/plugins/plugins/#","page":"Plugins","title":"Plugins","text":"At this point, NewPlugin is ready to be used. ","category":"page"},{"location":"manual/plugins/plugins/#Full-API-1","page":"Plugins","title":"Full API","text":"","category":"section"},{"location":"manual/plugins/plugins/#","page":"Plugins","title":"Plugins","text":"Plugins.Lyapunov\nPlugins.Fft\nPlugins.Mean\nPlugins.Std\nPlugins.Variance","category":"page"},{"location":"manual/plugins/plugins/#Jusdl.Plugins.Lyapunov","page":"Plugins","title":"Jusdl.Plugins.Lyapunov","text":"Lyapunov(;m::Int=15, J::Int=5, ni::Int=300, ts::Float64=0.01)\n\nConstructs a Lyapunov plugin. The process(plg::Lyapunov, x) function computes the maximum numerical Lyapunov exponents. m is the reconstruction dimension, J is the amount of delay in reconstruction, ni is the number of steps during transient steps and ts is the sampling time between samples of the input data x. See also: (https://juliadynamics.github.io/DynamicalSystems.jl/latest/chaos/nlts/)\n\n\n\n\n\n","category":"type"},{"location":"manual/plugins/plugins/#Jusdl.Plugins.Fft","page":"Plugins","title":"Jusdl.Plugins.Fft","text":"Fft(dims::Int)\n\nConstructs an Fft plugin. The  process(plg::Fft, x) function performes an fft operatinon along dims of x. See also: fft\n\n\n\n\n\n","category":"type"},{"location":"manual/plugins/plugins/#Jusdl.Plugins.Mean","page":"Plugins","title":"Jusdl.Plugins.Mean","text":"Mean(dims::Int)\n\nConstructs a Mean plugin. The process(plg::Mean, x) function takes the mean of the input data x along dimension dims.\n\n\n\n\n\n","category":"type"},{"location":"manual/plugins/plugins/#Jusdl.Plugins.Std","page":"Plugins","title":"Jusdl.Plugins.Std","text":"Std(dims::Int)\n\nConstructs a Std plugin. The process(plg::Std, x) function takes the standard deviation of the input data x along dimension dims.\n\n\n\n\n\n","category":"type"},{"location":"manual/plugins/plugins/#Jusdl.Plugins.Variance","page":"Plugins","title":"Jusdl.Plugins.Variance","text":"Variance(dims::Int)\n\nConstructs a Variance plugin. The process(plg::Variance, x) function takes the variance of the input data x along dimension dims.\n\n\n\n\n\n","category":"type"},{"location":"manual/models/simulation/#Simulation-1","page":"Simulation","title":"Simulation","text":"","category":"section"},{"location":"manual/models/simulation/#","page":"Simulation","title":"Simulation","text":"During the simulation of a model, a Simulation object is constructed. The field names of the Simulation object is ","category":"page"},{"location":"manual/models/simulation/#","page":"Simulation","title":"Simulation","text":"model::Model: The model for which the Simulation is constructed. \npath::String: The path of the directory into which all simulation-related files (log, data files etc.) are saved.\nlogger::AbstractLogger: The logger of the simulation constructed to log each stage of the Simulation . \nstate::Symbol: The state of the Simulation. The state may be :running if the simulation is running, :halted is the simulation is terminated without being completed, :done if it is terminated.\nretcode::Symbol: The return code of the simulation. The retcode may be :success if the simulation is completed without errors, :failed if the an error occurs during the simulation. ","category":"page"},{"location":"manual/models/simulation/#Full-API-1","page":"Simulation","title":"Full API","text":"","category":"section"},{"location":"manual/models/simulation/#","page":"Simulation","title":"Simulation","text":"setlogger\ncloselogger\nreport\nSimulationError","category":"page"},{"location":"manual/models/simulation/#Jusdl.Models.setlogger","page":"Simulation","title":"Jusdl.Models.setlogger","text":"setlogger(path, name; setglobal::Bool=true)\n\nReturns a logger. path is the path and name is the name of the file of the logger. If setglobal is true, the returned logger is a global logger.\n\nExample\n\njulia> logger = setlogger(tempdir(), \"mylogger\", setglobal=true)\nBase.CoreLogging.SimpleLogger(IOStream(<file /tmp/mylogger>), Info, Dict{Any,Int64}())\n\n\n\n\n\n","category":"function"},{"location":"manual/models/simulation/#Jusdl.Models.closelogger","page":"Simulation","title":"Jusdl.Models.closelogger","text":"closelogger(logger=global_logger())\n\nCloses the logger the file of the loggger. See also: setlogger\n\n\n\n\n\n","category":"function"},{"location":"manual/models/simulation/#Jusdl.Models.report","page":"Simulation","title":"Jusdl.Models.report","text":"report(simulation::Simulation)\n\nRecords the state of the simulation by writing all its fields into a data file. All the fields of the simulation is written into file. When the file is read back, the simulation object is constructed back. The data file is written under the path of the simulation.\n\n\n\n\n\n","category":"function"},{"location":"manual/models/simulation/#Jusdl.Models.SimulationError","page":"Simulation","title":"Jusdl.Models.SimulationError","text":"SimulationError(msg::String)\n\nThrown when an error occurs during a simulation.\n\n\n\n\n\n","category":"type"},{"location":"manual/components/sinks/scope/#Scope-1","page":"Scope","title":"Scope","text":"","category":"section"},{"location":"manual/components/sinks/scope/#Basic-Operation-of-Scopes-1","page":"Scope","title":"Basic Operation of Scopes","text":"","category":"section"},{"location":"manual/components/sinks/scope/#","page":"Scope","title":"Scope","text":"See Basic Operation of Writers since the operation of Writer and that of Scope is very similar.","category":"page"},{"location":"manual/components/sinks/scope/#Full-API-1","page":"Scope","title":"Full API","text":"","category":"section"},{"location":"manual/components/sinks/scope/#","page":"Scope","title":"Scope","text":"Scope \nupdate!(s::Scope, x, yi)\nclose(sink::Scope)\nopen(sink::Scope)","category":"page"},{"location":"manual/components/sinks/scope/#Jusdl.Components.Sinks.Scope","page":"Scope","title":"Jusdl.Components.Sinks.Scope","text":"Scope(input::Bus, buflen::Int=64, plugin=nothing, args...; kwargs...)\n\nConstructs a Scope with input bus input. buflen is the length of the internal buffer of Scope. plugin is the additional data processing tool. args,kwargs are passed into plots(args...; kwargs...)). See (https://github.com/JuliaPlots/Plots.jl) for more information.\n\nwarning: Warning\nWhen initialized, the plot of Scope is closed. See open(sink::Scope) and close(sink::Scope).\n\n\n\n\n\n","category":"type"},{"location":"manual/components/sinks/scope/#Jusdl.Components.ComponentsBase.update!-Tuple{Scope,Any,Any}","page":"Scope","title":"Jusdl.Components.ComponentsBase.update!","text":"update!(s::Scope, x, yi)\n\nUpdates the series of the plot windows of s with x and yi.\n\n\n\n\n\n","category":"method"},{"location":"manual/components/sinks/scope/#Base.close-Tuple{Scope}","page":"Scope","title":"Base.close","text":"close(sink::Scope)\n\nCloses the plot window of the plot of sink.\n\n\n\n\n\n","category":"method"},{"location":"manual/components/sinks/scope/#Base.open-Tuple{Scope}","page":"Scope","title":"Base.open","text":"open(sink::Scope)\n\nOpens the plot window for the plots of sink.\n\n\n\n\n\n","category":"method"},{"location":"manual/components/systems/dynamicsystems/discretesystem/#DiscreteSystem-1","page":"DiscreteSystem","title":"DiscreteSystem","text":"","category":"section"},{"location":"manual/components/systems/dynamicsystems/discretesystem/#Construction-of-DiscreteSystem-1","page":"DiscreteSystem","title":"Construction of DiscreteSystem","text":"","category":"section"},{"location":"manual/components/systems/dynamicsystems/discretesystem/#","page":"DiscreteSystem","title":"DiscreteSystem","text":"DiscreteSystems evolve by the following discrete time difference equation.","category":"page"},{"location":"manual/components/systems/dynamicsystems/discretesystem/#","page":"DiscreteSystem","title":"DiscreteSystem","text":"    x_k + 1 = f(x_k u_k k) \n    y_k = g(x_k u_k k)","category":"page"},{"location":"manual/components/systems/dynamicsystems/discretesystem/#","page":"DiscreteSystem","title":"DiscreteSystem","text":"where x_k is the state, y_k is the value of output and u_k is the value of input at discrete time t. f is the state function and g is the output function of the system. See the main constructor.","category":"page"},{"location":"manual/components/systems/dynamicsystems/discretesystem/#Basic-Construction-of-DiscreteSystem-1","page":"DiscreteSystem","title":"Basic Construction of DiscreteSystem","text":"","category":"section"},{"location":"manual/components/systems/dynamicsystems/discretesystem/#","page":"DiscreteSystem","title":"DiscreteSystem","text":"When a DiscreteSystem is triggered from its trigger link, it reads current time from its trigger link, reads its input, solves its difference equation, computes its output and writes its output value to its output bus. Let us continue with an example.","category":"page"},{"location":"manual/components/systems/dynamicsystems/discretesystem/#","page":"DiscreteSystem","title":"DiscreteSystem","text":"We first define state function sfunc and output function ofunc of the system,","category":"page"},{"location":"manual/components/systems/dynamicsystems/discretesystem/#","page":"DiscreteSystem","title":"DiscreteSystem","text":"using Jusdl # hide \nsfunc(dx, x, u, t) = (dx .= -0.5x)\nofunc(x, u, t) = x","category":"page"},{"location":"manual/components/systems/dynamicsystems/discretesystem/#","page":"DiscreteSystem","title":"DiscreteSystem","text":"From sfunc, it is seen that the system does not have any input, and from ofunc the system has one output. Thus, the input and output of the system is ","category":"page"},{"location":"manual/components/systems/dynamicsystems/discretesystem/#","page":"DiscreteSystem","title":"DiscreteSystem","text":"input = nothing \noutput = Bus(1)","category":"page"},{"location":"manual/components/systems/dynamicsystems/discretesystem/#","page":"DiscreteSystem","title":"DiscreteSystem","text":"We also need to specify the initial condition and time of the system","category":"page"},{"location":"manual/components/systems/dynamicsystems/discretesystem/#","page":"DiscreteSystem","title":"DiscreteSystem","text":"x0  = [1.]\nt = 0.","category":"page"},{"location":"manual/components/systems/dynamicsystems/discretesystem/#","page":"DiscreteSystem","title":"DiscreteSystem","text":"We are now ready to construct the system ds.","category":"page"},{"location":"manual/components/systems/dynamicsystems/discretesystem/#","page":"DiscreteSystem","title":"DiscreteSystem","text":"ds = DiscreteSystem(input, output, sfunc, ofunc, x0, t)","category":"page"},{"location":"manual/components/systems/dynamicsystems/discretesystem/#","page":"DiscreteSystem","title":"DiscreteSystem","text":"To drive ds, we need to launch it.","category":"page"},{"location":"manual/components/systems/dynamicsystems/discretesystem/#","page":"DiscreteSystem","title":"DiscreteSystem","text":"task = launch(ds)","category":"page"},{"location":"manual/components/systems/dynamicsystems/discretesystem/#","page":"DiscreteSystem","title":"DiscreteSystem","text":"At this point, ds is ready to be driven. To drive ds, we can either use drive(ds, t) or put!(ds.trigger, t). ","category":"page"},{"location":"manual/components/systems/dynamicsystems/discretesystem/#","page":"DiscreteSystem","title":"DiscreteSystem","text":"drive(ds, 1.)","category":"page"},{"location":"manual/components/systems/dynamicsystems/discretesystem/#","page":"DiscreteSystem","title":"DiscreteSystem","text":"When the above code is executed, ds evolves until its time is ds.t is 1., During this evolution, ds reads time t from its trigger link, reads its input (in this example, ds has no input, so it does nothing when reading its input), solves its difference equation, computes its output and writes its output value to its output. To signal that the evolution is succeeded, ds writes true its handshake link which needs to be taken to further drive ds.","category":"page"},{"location":"manual/components/systems/dynamicsystems/discretesystem/#","page":"DiscreteSystem","title":"DiscreteSystem","text":"ds.handshake  # `handshake` link is readable\ntake!(ds.handshake)","category":"page"},{"location":"manual/components/systems/dynamicsystems/discretesystem/#","page":"DiscreteSystem","title":"DiscreteSystem","text":"We continue to drive ds,","category":"page"},{"location":"manual/components/systems/dynamicsystems/discretesystem/#","page":"DiscreteSystem","title":"DiscreteSystem","text":"for i in 2. : 10. \n    drive(ds, i)\n    take!(ds.handshake)\nend","category":"page"},{"location":"manual/components/systems/dynamicsystems/discretesystem/#","page":"DiscreteSystem","title":"DiscreteSystem","text":"Note that all the output values of ds is written to its output bus.","category":"page"},{"location":"manual/components/systems/dynamicsystems/discretesystem/#","page":"DiscreteSystem","title":"DiscreteSystem","text":"ds.output[1].buffer.data","category":"page"},{"location":"manual/components/systems/dynamicsystems/discretesystem/#","page":"DiscreteSystem","title":"DiscreteSystem","text":"When we launched ds, we constructed a task which is still running.","category":"page"},{"location":"manual/components/systems/dynamicsystems/discretesystem/#","page":"DiscreteSystem","title":"DiscreteSystem","text":"task","category":"page"},{"location":"manual/components/systems/dynamicsystems/discretesystem/#","page":"DiscreteSystem","title":"DiscreteSystem","text":"As long nothing goes wrong, i.e. no exception is thrown, during the evolution of ds, it is possible to drive ds. To safely terminate the task, we need to terminate the ds. ","category":"page"},{"location":"manual/components/systems/dynamicsystems/discretesystem/#","page":"DiscreteSystem","title":"DiscreteSystem","text":"terminate(ds)","category":"page"},{"location":"manual/components/systems/dynamicsystems/discretesystem/#","page":"DiscreteSystem","title":"DiscreteSystem","text":"We can confirm that the task is not running and its state is done.","category":"page"},{"location":"manual/components/systems/dynamicsystems/discretesystem/#","page":"DiscreteSystem","title":"DiscreteSystem","text":"task","category":"page"},{"location":"manual/components/systems/dynamicsystems/discretesystem/#","page":"DiscreteSystem","title":"DiscreteSystem","text":"Since the task is not running any more, ds cannot be drivable any more. However to drive ds again, we need launch ds again.","category":"page"},{"location":"manual/components/systems/dynamicsystems/discretesystem/#Full-API-1","page":"DiscreteSystem","title":"Full API","text":"","category":"section"},{"location":"manual/components/systems/dynamicsystems/discretesystem/#","page":"DiscreteSystem","title":"DiscreteSystem","text":"DiscreteSystem","category":"page"},{"location":"manual/components/systems/dynamicsystems/discretesystem/#Jusdl.Components.Systems.DynamicSystems.DiscreteSystem","page":"DiscreteSystem","title":"Jusdl.Components.Systems.DynamicSystems.DiscreteSystem","text":"DiscreteSystem(input, output, statefunc, outputfunc, state, t;  solver=DiscreteSolver)\n\nConstruct a DiscreteSystem with input and output. statefunc is the state function and outputfunc is the output function of DiscreteSystem. state is the state and t is the current time of t. solver is numerical difference eqaution solver of the system. The system is represented by\n\n    beginarrayl\n        x_k + 1 = f(x_k u_k k) \n        y_k = g(x_k u_k k)\n    endarray\n\nwhere x_k is the state,  y_k is the value of output, u_k is the value of input at dicrete time k. f is statefunc andg`isoutputfunc`. \n\nThe signature of statefunc must be of the form \n\nfunction statefunc(dx, x, u, t)\n    dx = ...   # Update dx\nend\n\nand the signature of outputfunc must be of the form \n\nfunction outputfunc(x, u, t)\n    y = ...   # Compute y\n    return y\nend\n\nExample\n\njulia> sfunc(dx,x,u,t) = (dx .= 0.5x)\nsfunc (generic function with 1 method)\njulia> ofunc(x, u, t) = x\nofunc (generic function with 1 method)\n\njulia> ds = DiscreteSystem(Bus(1), Bus(1), sfunc, ofunc, [1.], 0.)\nDiscreteSystem(state:[1.0], t:0.0, input:Bus(nlinks:1, eltype:Link{Float64}, isreadable:false, iswritable:false), output:Bus(nlinks:1, eltype:Link{Float64}, isreadable:false, iswritable:false))\n\n\n\n\n\n","category":"type"},{"location":"manual/utilities/buffers/#Buffer-1","page":"Buffer","title":"Buffer","text":"","category":"section"},{"location":"manual/utilities/buffers/#","page":"Buffer","title":"Buffer","text":"DocTestSetup  = quote\n    using Jusdl\n    import Utilities: BufferMode, LinearMode, CyclicMode\nend","category":"page"},{"location":"manual/utilities/buffers/#","page":"Buffer","title":"Buffer","text":"Buffer is a primitive to buffer the data. Data can be of any Julia type. Data can be read from and written into a buffer, and the mode of the buffer determines the way to read from and write into the buffers. ","category":"page"},{"location":"manual/utilities/buffers/#Buffer-Modes-1","page":"Buffer","title":"Buffer Modes","text":"","category":"section"},{"location":"manual/utilities/buffers/#","page":"Buffer","title":"Buffer","text":"Buffer mode determines the way the data is read from and written into a Buffer. ","category":"page"},{"location":"manual/utilities/buffers/#","page":"Buffer","title":"Buffer","text":"Utilities.BufferMode \nUtilities.LinearMode \nUtilities.CyclicMode","category":"page"},{"location":"manual/utilities/buffers/#Jusdl.Utilities.BufferMode","page":"Buffer","title":"Jusdl.Utilities.BufferMode","text":"BufferMode\n\nAbstract type for buffer mode. Subtypes of BufferMode is CyclicMode and LinearMode.\n\n\n\n\n\n","category":"type"},{"location":"manual/utilities/buffers/#Jusdl.Utilities.LinearMode","page":"Buffer","title":"Jusdl.Utilities.LinearMode","text":"LinearMode <: BufferMode\n\nAbstract type of linear buffer modes. See Normal, Lifo, Fifo\n\n\n\n\n\n","category":"type"},{"location":"manual/utilities/buffers/#Jusdl.Utilities.CyclicMode","page":"Buffer","title":"Jusdl.Utilities.CyclicMode","text":"CyclicMode <: BufferMode\n\nAbstract type of cyclic buffer modes. See Cyclic\n\n\n\n\n\n","category":"type"},{"location":"manual/utilities/buffers/#","page":"Buffer","title":"Buffer","text":"There are four different buffer modes.","category":"page"},{"location":"manual/utilities/buffers/#","page":"Buffer","title":"Buffer","text":"Normal\nCyclic\nLifo \nFifo","category":"page"},{"location":"manual/utilities/buffers/#Jusdl.Utilities.Normal","page":"Buffer","title":"Jusdl.Utilities.Normal","text":"Normal <: LinearMode\n\nLinearMode buffer mode. The data is written to buffer until the buffer is full. When it is full, no more data is written to the buffer. When read, the data written last is returned and the returned data is not deleted from the internal container of the buffer. \n\n\n\n\n\n","category":"type"},{"location":"manual/utilities/buffers/#Jusdl.Utilities.Cyclic","page":"Buffer","title":"Jusdl.Utilities.Cyclic","text":"Cyclic <: CyclicMode\n\nCyclic buffer mode. The data is written to buffer until the buffer is full. When the buffer is full, new data is written by overwriting the data available in the buffer starting from the beginning of the buffer. When the buffer is read, the element written last is returned and the returned element is not deleted from the buffer.\n\n\n\n\n\n","category":"type"},{"location":"manual/utilities/buffers/#Jusdl.Utilities.Lifo","page":"Buffer","title":"Jusdl.Utilities.Lifo","text":"Lifo <: LinearMode\n\nLifo (Last-in-first-out) buffer mode. This type of buffer is a last-in-first-out buffer. Data is written to the buffer until the buffer is full. When the buffer is full, no more element can be written into the buffer. When read, the last element written into buffer is returned. The returned element is deleted from the buffer.\n\n\n\n\n\n","category":"type"},{"location":"manual/utilities/buffers/#Jusdl.Utilities.Fifo","page":"Buffer","title":"Jusdl.Utilities.Fifo","text":"Fifo <: LinearMode\n\nFifo (First-in-last-out) buffer mode. This type of buffer is a first-in-first-out buffer. The data is written to the buffer until the buffer is full. When the buffer is full, no more element can be written into the buffer. When read, the first element written into the buffer is returned. The returned element is deleted from the buffer. \n\n\n\n\n\n","category":"type"},{"location":"manual/utilities/buffers/#Buffer-Constructors-1","page":"Buffer","title":"Buffer Constructors","text":"","category":"section"},{"location":"manual/utilities/buffers/#","page":"Buffer","title":"Buffer","text":"The Buffer construction is very similar to the construction of arrays in Julia. Just specify the mode, element type and length of the buffer. Here are the main Buffer constructors: ","category":"page"},{"location":"manual/utilities/buffers/#","page":"Buffer","title":"Buffer","text":"Buffer","category":"page"},{"location":"manual/utilities/buffers/#Jusdl.Utilities.Buffer","page":"Buffer","title":"Jusdl.Utilities.Buffer","text":"Buffer{M}(dtype::Type{T}, sz::Int...) where {M, T}\n\nConstructs a Buffer of size sz with element type of T. M is the mode of the Buffer that determines how data is to read from and written into the Buffer.  There exists for different buffer modes: \n\nNormal: See Normal\nCyclic: See Cyclic\nLifo: See Lifo\nFifo: See Fifo\n\nThe default mode for Buffer is Cyclic and default element type is Float64.\n\nBuffer{M}(sz::Int...) where {M, T}\n\nConstructs a Buffer of size sz and with element type of T and mode M.\n\nBuffer(dtype::Type{T}, sz::Int...) where T\n\nConstructs a Buffer of size sz and element type T. The mode of buffer is Cyclic.\n\nBuffer(sz::Int...)\n\nConstructs a Buffer of size sz with mode Cyclic and element type of Float64.\n\n\n\n\n\n","category":"type"},{"location":"manual/utilities/buffers/#","page":"Buffer","title":"Buffer","text":"warning: Warning\nNote that Buffer is one dimensional. That is, the length of the data must be specified when constructing a Buffer. ","category":"page"},{"location":"manual/utilities/buffers/#","page":"Buffer","title":"Buffer","text":"warning: Warning\nNote that when a Buffer is initialized, the internal data of the Buffer is of missing. ","category":"page"},{"location":"manual/utilities/buffers/#","page":"Buffer","title":"Buffer","text":"Let us try some examples. Here are some simple buffer construction.","category":"page"},{"location":"manual/utilities/buffers/#","page":"Buffer","title":"Buffer","text":"using Jusdl # hide\nbuf1 = Buffer{Normal}(Float64, 5)   # Buffer of length `5` with mode `Normal` and element type of `Float64`. \nbuf2 = Buffer{Fifo}(Int, 3)       # Buffer of length `5` with mode `Fifo` and element type of `Int`. \nbuf3 = Buffer(Vector{Int}, 3)       # Buffer of length `5` with mode `Cyclic` and element type of `Vector{Int}`. \nbuf4 = Buffer(Matrix{Float64}, 5)    # Buffer of length `5` with mode `Cyclic` and element type of `Matrix{Float64}`. \nbuf5 = Buffer(5)                    # Buffer of length `5` with mode `Cyclic` and element type of `Float64`.","category":"page"},{"location":"manual/utilities/buffers/#","page":"Buffer","title":"Buffer","text":"Note that the element type of Buffer can be any Julia type, even any user-defined type. Note the following example, ","category":"page"},{"location":"manual/utilities/buffers/#","page":"Buffer","title":"Buffer","text":"using Jusdl #hide \nstruct Object end       # Define a dummy type. \nbuf = Buffer{Normal}(Object, 4)  # Buffer of length `4` with element type `Object`.","category":"page"},{"location":"manual/utilities/buffers/#Writing-Data-into-Buffers-1","page":"Buffer","title":"Writing Data into Buffers","text":"","category":"section"},{"location":"manual/utilities/buffers/#","page":"Buffer","title":"Buffer","text":"Writing data into a Buffer is done with write! function.","category":"page"},{"location":"manual/utilities/buffers/#","page":"Buffer","title":"Buffer","text":"write!","category":"page"},{"location":"manual/utilities/buffers/#Jusdl.Utilities.write!","page":"Buffer","title":"Jusdl.Utilities.write!","text":"write!(writer, td, xd)\n\nWrites xd corresponding to xd to the file of writer.\n\nExample\n\njulia> w = Writer(Bus(1))\nWriter(path:/tmp/e907d6ad-8db2-4c4a-9959-5b8d33d32156.jld2, nin:1)\n\njulia> open(w)\nWriter(path:/tmp/e907d6ad-8db2-4c4a-9959-5b8d33d32156.jld2, nin:1)\n\njulia> write!(w, 0., 10.)\n10.0\n\njulia> write!(w, 1., 20.)\n20.0\n\njulia> w.file\nJLDFile /tmp/e907d6ad-8db2-4c4a-9959-5b8d33d32156.jld2 (read/write)\n ├─🔢 0.0\n └─🔢 1.0\n\njulia> w.file[string(0.)]\n10.0\n\n\n\n\n\nwrite!(buf::Buffer{M, T}, val) where {M, T}\n\nWrites val into buf. Writing is carried occurding the mode M of buf. See also: Normal, Cyclic, Lifo, Fifo for buffer modes. \n\n\n\n\n\n","category":"function"},{"location":"manual/utilities/buffers/#","page":"Buffer","title":"Buffer","text":"Recall that when the buffer is full, no more data can be written into the buffer if the buffer mode is of type LinearMode. ","category":"page"},{"location":"manual/utilities/buffers/#","page":"Buffer","title":"Buffer","text":"using Jusdl # hide\nnormalbuf = Buffer{Normal}(3)\nfill!(normalbuf, 1.)\nnormalbuf.data \nwrite!(normalbuf, 1.)","category":"page"},{"location":"manual/utilities/buffers/#","page":"Buffer","title":"Buffer","text":"This situation is the same for Lifo and Fifo buffers, but not the case for Cyclic buffer. ","category":"page"},{"location":"manual/utilities/buffers/#","page":"Buffer","title":"Buffer","text":"using Jusdl # hide\nnormalbuf = Buffer{Cyclic}(3)\nfill!(normalbuf, 1.)\nnormalbuf.data \nwrite!(normalbuf, 3.)\nwrite!(normalbuf, 4.)","category":"page"},{"location":"manual/utilities/buffers/#","page":"Buffer","title":"Buffer","text":"warning: Warning\nSince when a Buffer is constructed, it is empty, no data is written to it. But it is initialized with missing data. Thus, the element type of buffer of type Buffer{M, T} where {M, T} is Union{Missing, T} where T. Benchmarks that has been carried out shows that there is no performance bottle neck is such design since Julia's compiler can compile optimized code for such a small unions. Therefore it is possible to write missing into a buffer of type Buffer{M,T} where {M,T}.","category":"page"},{"location":"manual/utilities/buffers/#Reading-Data-from-Buffers-1","page":"Buffer","title":"Reading Data from Buffers","text":"","category":"section"},{"location":"manual/utilities/buffers/#","page":"Buffer","title":"Buffer","text":"Reading data from a Buffer is done with read function.","category":"page"},{"location":"manual/utilities/buffers/#","page":"Buffer","title":"Buffer","text":"read","category":"page"},{"location":"manual/utilities/buffers/#Base.read","page":"Buffer","title":"Base.read","text":"read(writer::Writer, flatten=false)\n\nRead the contents of the file of writer and returns the sorted content of the file. If flatten is true, the content is also flattened.\n\n\n\n\n\nread(buf::Buffer)\n\nReads an element from buf. Reading is performed according to the mode of buf. See also: Normal, Cyclic, Lifo, Fifo for buffer modes. \n\n\n\n\n\n","category":"function"},{"location":"manual/utilities/buffers/#AbstractArray-Interface-of-Buffers-1","page":"Buffer","title":"AbstractArray Interface of Buffers","text":"","category":"section"},{"location":"manual/utilities/buffers/#","page":"Buffer","title":"Buffer","text":"A Buffer can be indexed using the similar syntax of arrays in Julia. That is, getindex and setindex! methods can be used with known Julia syntax. i.e. getindex(buf, idx) is equal to buf[idx] and setindex(buf, val, idx) is equal to buf[idx] = val.","category":"page"},{"location":"manual/utilities/buffers/#","page":"Buffer","title":"Buffer","text":"using Jusdl  # hide\nbuf = Buffer(5)\nsize(buf)\nlength(buf)\nfor val in 1 : 5 \n    write!(buf, 2val)\nend \nbuf[1]\nbuf[3:4]\nbuf[[3, 5]]\nbuf[end]\nbuf[1] = 5 \nbuf[3:5] = [7, 8, 9]","category":"page"},{"location":"manual/utilities/buffers/#Full-API-1","page":"Buffer","title":"Full API","text":"","category":"section"},{"location":"manual/utilities/buffers/#","page":"Buffer","title":"Buffer","text":"fill!\nisempty\nisfull\ncontent\nmode\nsnapshot","category":"page"},{"location":"manual/utilities/buffers/#Base.fill!","page":"Buffer","title":"Base.fill!","text":"fill!(buf::Buffer, val)\n\nWrites val to buf until bus is full.\n\n\n\n\n\n","category":"function"},{"location":"manual/utilities/buffers/#Base.isempty","page":"Buffer","title":"Base.isempty","text":"isempty(buf::Buffer)\n\nReturns true if the index of buf is 1.\n\n\n\n\n\n","category":"function"},{"location":"manual/utilities/buffers/#Jusdl.Utilities.isfull","page":"Buffer","title":"Jusdl.Utilities.isfull","text":"isfull(buf::Buffer)\n\nReturns true if the index of buf is equal to the length of buf.\n\n\n\n\n\n","category":"function"},{"location":"manual/utilities/buffers/#Jusdl.Utilities.content","page":"Buffer","title":"Jusdl.Utilities.content","text":"content(buf, [flip=true])\n\nReturns the current data of buf. If flip is true, the data to be returned is flipped. \n\n\n\n\n\n","category":"function"},{"location":"manual/utilities/buffers/#Jusdl.Utilities.mode","page":"Buffer","title":"Jusdl.Utilities.mode","text":"mode(buf::Buffer)\n\nReturns buffer mode of buf. See also: Normal, Cyclic, Lifo, Fifo for buffer modes. \n\n\n\n\n\n","category":"function"},{"location":"manual/utilities/buffers/#Jusdl.Utilities.snapshot","page":"Buffer","title":"Jusdl.Utilities.snapshot","text":"snapshot(buf::Buffer)\n\nReturns all elements in buf.\n\n\n\n\n\n","category":"function"},{"location":"manual/components/sources/clock/#Clock-1","page":"Clock","title":"Clock","text":"","category":"section"},{"location":"manual/components/sources/clock/#","page":"Clock","title":"Clock","text":"Jusdl is a clocked simulation environment. That is, model components are evolved in different time intervals, called as sampling interval. During the simulation, model components are triggered by these generated time pulses.  The Clock type is used to to generate those time pulses. The simulation time settings, the simulation start time, stop time, sampling interval are configured through the Clocks.","category":"page"},{"location":"manual/components/sources/clock/#Construction-of-Clock-1","page":"Clock","title":"Construction of Clock","text":"","category":"section"},{"location":"manual/components/sources/clock/#","page":"Clock","title":"Clock","text":"Construction of Clock is done by specifying its start time and final time and the simulation sampling period. ","category":"page"},{"location":"manual/components/sources/clock/#","page":"Clock","title":"Clock","text":"Clock","category":"page"},{"location":"manual/components/sources/clock/#Jusdl.Components.Sources.Clock","page":"Clock","title":"Jusdl.Components.Sources.Clock","text":"Clock(t::Real, dt::Real, tf::Real)\n\nConstructs a Clock with starting time t, final time tf and sampling inteval dt. When iterated, the Clock returns its current time. \n\nwarning: Warning\nWhen constructed, Clock is not running. To take clock ticks from Clock, the Clock must be setted. See take!(clk::Clock) and set! \n\n\n\n\n\n","category":"type"},{"location":"manual/components/sources/clock/#Basic-Usage-of-Clocks-1","page":"Clock","title":"Basic Usage of Clocks","text":"","category":"section"},{"location":"manual/components/sources/clock/#","page":"Clock","title":"Clock","text":"A Clock instance has a Callback list so that a Callback can be constructed to trigger specific events configured with the time settings. See the following case study. ","category":"page"},{"location":"manual/components/sources/clock/#","page":"Clock","title":"Clock","text":"Let us consider a Clock with initial time of 0, sampling interval of 1 and final time of 10.","category":"page"},{"location":"manual/components/sources/clock/#","page":"Clock","title":"Clock","text":"using Jusdl # hide \nclk = Clock(0., 1., 10.)","category":"page"},{"location":"manual/components/sources/clock/#","page":"Clock","title":"Clock","text":"Notice that clk is not running, since it is not set. Now, let us set it","category":"page"},{"location":"manual/components/sources/clock/#","page":"Clock","title":"Clock","text":"set!(clk)","category":"page"},{"location":"manual/components/sources/clock/#","page":"Clock","title":"Clock","text":"clk is ready to run, i.e., to be iterated. The following commands generated clock ticks and shows it on the console.","category":"page"},{"location":"manual/components/sources/clock/#","page":"Clock","title":"Clock","text":"for t in clk \n    @show t \nend","category":"page"},{"location":"manual/components/sources/clock/#","page":"Clock","title":"Clock","text":"At this point, clk is out of time. The current time of clk does not advance any more. ","category":"page"},{"location":"manual/components/sources/clock/#","page":"Clock","title":"Clock","text":"take!(clk)","category":"page"},{"location":"manual/components/sources/clock/#","page":"Clock","title":"Clock","text":"But, clk can be reset again.","category":"page"},{"location":"manual/components/sources/clock/#","page":"Clock","title":"Clock","text":"set!(clk, 0., 1., 10.)","category":"page"},{"location":"manual/components/sources/clock/#","page":"Clock","title":"Clock","text":"Consider that we want to configure and alarm. For this, let us consider that when the time of clk is greater than 5 an alarm message is printed on console. To this end, we need to construct a Callback and add it to the callbacks of clk. (When constructed callback list of clk is empty.)","category":"page"},{"location":"manual/components/sources/clock/#","page":"Clock","title":"Clock","text":"condition(clk) = clk.t > 5\naction(clk) = println(\"Clock time = \", clk.t)\ncallback = Callback(condition, action)\naddcallback(clk, callback)","category":"page"},{"location":"manual/components/sources/clock/#","page":"Clock","title":"Clock","text":"Now, let us run clk by iterating it. ","category":"page"},{"location":"manual/components/sources/clock/#","page":"Clock","title":"Clock","text":"for t in clk \n    @show t \nend ","category":"page"},{"location":"manual/components/sources/clock/#","page":"Clock","title":"Clock","text":"Note that we, constructed a simple callback. It is of course possible to construct more complex callbacks.","category":"page"},{"location":"manual/components/sources/clock/#Usage-of-Clocks-with-ProgressMeter-1","page":"Clock","title":"Usage of Clocks with ProgressMeter","text":"","category":"section"},{"location":"manual/components/sources/clock/#","page":"Clock","title":"Clock","text":"It also possible to iterate the Clocks by using a progress meter. See ProgressMeter for further information for progress meter.","category":"page"},{"location":"manual/components/sources/clock/#","page":"Clock","title":"Clock","text":"using Jusdl\nusing ProgressMeter\nclk = Clock(0., 0.01, 1.)\nset!(clk)\n@showprogress for t in clk \nend ","category":"page"},{"location":"manual/components/sources/clock/#","page":"Clock","title":"Clock","text":"Note that clk is just iterated.","category":"page"},{"location":"manual/components/sources/clock/#Full-API-1","page":"Clock","title":"Full API","text":"","category":"section"},{"location":"manual/components/sources/clock/#","page":"Clock","title":"Clock","text":"take!(clk::Clock)\nisrunning\nispaused\nisoutoftime\nset!\nstop!\npause!\niterate(clk::Clock)","category":"page"},{"location":"manual/components/sources/clock/#Base.take!-Tuple{Clock}","page":"Clock","title":"Base.take!","text":"take!(clk::Clock)\n\nTakes a values from clk.\n\nExample\n\nulia> clk = Clock(0., 0.1, 0.5)\nClock(t:0.0, dt:0.1, tf:0.5, paused:false, isrunning:false)\n\njulia> set!(clk)\nClock(t:0.0, dt:0.1, tf:0.5, paused:false, isrunning:true)\n\njulia> for i = 0 : 5 \n       @show take!(clk)\n       end\ntake!(clk) = 0.0\ntake!(clk) = 0.1\ntake!(clk) = 0.2\ntake!(clk) = 0.3\ntake!(clk) = 0.4\ntake!(clk) = 0.5\n\n\n\n\n\n","category":"method"},{"location":"manual/components/sources/clock/#Jusdl.Components.Sources.isrunning","page":"Clock","title":"Jusdl.Components.Sources.isrunning","text":"isrunning(clk::Clock)\n\nReturns true if clk if clk is running.\n\n\n\n\n\n","category":"function"},{"location":"manual/components/sources/clock/#Jusdl.Components.Sources.ispaused","page":"Clock","title":"Jusdl.Components.Sources.ispaused","text":"ispaused(clk::Clock)\n\nReturns true if clk is paused. When paused, the currnent time of clk is not advanced. See also pause!(clk::Clock)\n\n\n\n\n\n","category":"function"},{"location":"manual/components/sources/clock/#Jusdl.Components.Sources.isoutoftime","page":"Clock","title":"Jusdl.Components.Sources.isoutoftime","text":"isoutoftime(clk::Clock)\n\nReturns true if clk is out of time, i.e., the current time of clk exceeds its final time. \n\n\n\n\n\n","category":"function"},{"location":"manual/components/sources/clock/#Jusdl.Components.Sources.set!","page":"Clock","title":"Jusdl.Components.Sources.set!","text":"set(clk::Clock, t::Real, dt::Real, tf::Real)\n\nSets clk for current clock time t, sampling time dt and final time tf. After the set,  it is possible to take clock tick from clk. See also take!(clk::Clock)\n\nExample\n\njulia> clk = Clock(0., 0.1, 0.5)\nClock(t:0.0, dt:0.1, tf:0.5, paused:false, isrunning:false)\n\njulia> take!(clk)\n┌ Warning: Clock is not running.\n└ @ Jusdl.Components.Sources ~/.julia/dev/Jusdl/src/components/sources/clock.jl:47\n0.0\n\njulia> set!(clk)\nClock(t:0.0, dt:0.1, tf:0.5, paused:false, isrunning:true)\n\njulia> take!(clk)\n0.0\n\n\n\n\n\n","category":"function"},{"location":"manual/components/sources/clock/#Jusdl.Components.Sources.stop!","page":"Clock","title":"Jusdl.Components.Sources.stop!","text":"stop!(clk::Clock)\n\nUnsets clk. After the stpp, it is possible to take clock ticks from clk. See also take!(clk::Clock)\n\n\n\n\n\n","category":"function"},{"location":"manual/components/sources/clock/#Jusdl.Components.Sources.pause!","page":"Clock","title":"Jusdl.Components.Sources.pause!","text":"pause!(clk::Clock)\n\nPauses clk. When paused, the current time of clk does not advance.\n\nExample\n\njulia> clk = Clock(0., 0.1, 0.5);\n\njulia> set!(clk);\n\njulia> for i = 1 : 5\n       i > 3 && pause!(clk)\n       @show take!(clk)\n       end\n\ntake!(clk) = 0.0\ntake!(clk) = 0.1\ntake!(clk) = 0.2\n┌ Warning: Clock is paused.\n└ @ Jusdl.Components.Sources ~/.julia/dev/Jusdl/src/components/sources/clock.jl:58\ntake!(clk) = 0.2\n┌ Warning: Clock is paused.\n└ @ Jusdl.Components.Sources ~/.julia/dev/Jusdl/src/components/sources/clock.jl:58\ntake!(clk) = 0.2\n\n\n\n\n\n","category":"function"},{"location":"manual/components/sources/clock/#Base.iterate-Tuple{Clock}","page":"Clock","title":"Base.iterate","text":"iterate(clk::Clock[, t=clk.t)\n\nIterationk interface for clk. clk can be iterated in a loop.\n\nExample\n\njulia> clk = Clock(0., 0.1, 0.3);\n\njulia> set!(clk)\nClock(t:0.0, dt:0.1, tf:0.3, paused:false, isrunning:true)\n\njulia> for t in clk\n       @show t \n       end\nt = 0.0\nt = 0.1\nt = 0.2\nt = 0.3\n\n\n\n\n\n","category":"method"},{"location":"modeling_and_simulation/simulation/#Simulation-1","page":"Simulation","title":"Simulation","text":"","category":"section"},{"location":"modeling_and_simulation/simulation/#","page":"Simulation","title":"Simulation","text":"A model to be simulated consists of components connected to each other and a time reference. The time reference is used to sample the continuous time signals flowing through the busses of the model and to trigger the components. The simulation is performed by triggering the components with pulses generated by the time reference at simulation sampling time intervals. Having been triggered, the components evolve themselves, compute their outputs and writes them to their output busses.","category":"page"},{"location":"modeling_and_simulation/simulation/#","page":"Simulation","title":"Simulation","text":"<center>\n    <img src=\"../assets/FlowChart/flowchart.png\" alt=\"model\" width=\"75%\"/>\n</center>","category":"page"},{"location":"modeling_and_simulation/simulation/#","page":"Simulation","title":"Simulation","text":"Simulation stages are shown in the flowchart in Figure above. In the first stage, the model is inspected in terms of whether it has unterminated bussed, etc. In case an unterminated bus is inspected, then the simulation is terminated directly. It is also possible to enlarge the scope of the inspection stage to determine whether the model includes algebraic loops, etc.","category":"page"},{"location":"modeling_and_simulation/simulation/#","page":"Simulation","title":"Simulation","text":"If the inspection stage results positive, the initialization stage comes next. In this stage, the tasks required for the busses of the model to be both readable and writable are activated and bound to the busses. To this end, a putter and a taker task are activated and bound to both sides of each bus. For example, in Figure 2.5a is shown a part of a model consisting of the components B1, B2, B3, B4 and busses L1, L2, L3. When triggered, B1(B2) reads data from L1(L2) and writes data to L2(L3). The tasks that are bound on L1 and L2 are shown symbolically in Figure 2.5b. A taker and a putter task are bound to L1 and L2, respectively, corresponding to B1. Similarly, a taker and a putter task are bound to L2 and L3, respectively, corresponding to B2. As a putter task and a taker task is bound to L2, data-flow from B1 to B2 is possible through it.","category":"page"},{"location":"modeling_and_simulation/simulation/#","page":"Simulation","title":"Simulation","text":"The run stage follows the initialization stage. The tasks activated in initialization stage wait for the components to be triggered by the model time reference. During the run stage, time reference triggers the components by writing pulses that are generated in the intervals of the sampling period of the simulation to their trigger links. The job defined in a task is to read input data from its input bus, to calculate its next state—if any—and output, and to write its output to its output bus. The run stage starts at the initial time of the time reference and continues until the end time of the time reference.","category":"page"},{"location":"modeling_and_simulation/simulation/#","page":"Simulation","title":"Simulation","text":"After the run stage, the tasks opened in the initialization stage are closed and the simulation is terminated.","category":"page"},{"location":"modeling_and_simulation/simulation/#","page":"Simulation","title":"Simulation","text":"In some simulation environments, a unified mathematical equation represent- ing the model as a whole is obtained and solved in just a single shot for the entire simulation duration, even if the model is thought to consist of components[13]. In JuSDL, a model is, again, thought to consist of components, but is not represented by a unified mathematical equation. Instead, the model is evolved by evolving the components individually by solving their own mathematical equations. The components do not evolve in one shot, but instead, they evolve in parallel for during the time intervals between subsequent sampling instants. Here, it worths noting that the type of the mathematical equations of the components of a model does not have to be the same. Thus, JuSDL allows the simulation of the models consisting of components represented by different types of mathematical equations.","category":"page"},{"location":"manual/components/sinks/writer/#Writer-1","page":"Writer","title":"Writer","text":"","category":"section"},{"location":"manual/components/sinks/writer/#Basic-Operation-of-Writers-1","page":"Writer","title":"Basic Operation of Writers","text":"","category":"section"},{"location":"manual/components/sinks/writer/#","page":"Writer","title":"Writer","text":"Haiving launched, a Writer is triggered from its trigger link. When triggered, a Writer reads its input an writes to its internal buffer databuf. When databuf  is full, the data in databuf is processed. Thus, the length of the data that is to be processed by the Writer is determined by the length of their internal buffer databuf. ","category":"page"},{"location":"manual/components/sinks/writer/#","page":"Writer","title":"Writer","text":"Let us construct a Writer. ","category":"page"},{"location":"manual/components/sinks/writer/#","page":"Writer","title":"Writer","text":"using Jusdl # hide \nw = Writer(Bus(), buflen=5)","category":"page"},{"location":"manual/components/sinks/writer/#","page":"Writer","title":"Writer","text":"The file of w is closed and the trigger link of w is not writable. That is, it is not possible to trigger w from its trigger link.","category":"page"},{"location":"manual/components/sinks/writer/#","page":"Writer","title":"Writer","text":"w.file \nw.trigger","category":"page"},{"location":"manual/components/sinks/writer/#","page":"Writer","title":"Writer","text":"To trigger w, we need to open and launch it, ","category":"page"},{"location":"manual/components/sinks/writer/#","page":"Writer","title":"Writer","text":"open(w)\nt = launch(w)","category":"page"},{"location":"manual/components/sinks/writer/#","page":"Writer","title":"Writer","text":"Now, the internal file of w is opened in read/write mode and its trigger link is writable. ","category":"page"},{"location":"manual/components/sinks/writer/#","page":"Writer","title":"Writer","text":"w.file\nw.trigger","category":"page"},{"location":"manual/components/sinks/writer/#","page":"Writer","title":"Writer","text":"Let us now trigger w. ","category":"page"},{"location":"manual/components/sinks/writer/#","page":"Writer","title":"Writer","text":"put!(w.trigger, 1.)","category":"page"},{"location":"manual/components/sinks/writer/#","page":"Writer","title":"Writer","text":"The input of w is now readable and handshake link is not readable since w have not signalled that its triggering is succeeded yet. To do that, we need to put a value to the input of w","category":"page"},{"location":"manual/components/sinks/writer/#","page":"Writer","title":"Writer","text":"put!(w. input, [10.])","category":"page"},{"location":"manual/components/sinks/writer/#","page":"Writer","title":"Writer","text":"Now, w signalled that its step is succeeded. It read the data from its input and written it into is databuf. ","category":"page"},{"location":"manual/components/sinks/writer/#","page":"Writer","title":"Writer","text":"w.handshake\ntake!(w.handshake)\nw.databuf.data","category":"page"},{"location":"manual/components/sinks/writer/#","page":"Writer","title":"Writer","text":"Since the databuf is not full nothing is written to the file of w. ","category":"page"},{"location":"manual/components/sinks/writer/#","page":"Writer","title":"Writer","text":"w.file","category":"page"},{"location":"manual/components/sinks/writer/#","page":"Writer","title":"Writer","text":"Let us continue triggering w until the databuf of w is full.","category":"page"},{"location":"manual/components/sinks/writer/#","page":"Writer","title":"Writer","text":"for t in 2. : 5.\n    put!(w.trigger, t)\n    put!(w.input, [t * 10])\n    take!(w.handshake)\nend","category":"page"},{"location":"manual/components/sinks/writer/#","page":"Writer","title":"Writer","text":"Now check that the content of the file of w.","category":"page"},{"location":"manual/components/sinks/writer/#","page":"Writer","title":"Writer","text":"w.file","category":"page"},{"location":"manual/components/sinks/writer/#","page":"Writer","title":"Writer","text":"Note that the content of databuf is written to the file of w. The operation of w can be terminated. ","category":"page"},{"location":"manual/components/sinks/writer/#","page":"Writer","title":"Writer","text":"terminate(w)","category":"page"},{"location":"manual/components/sinks/writer/#","page":"Writer","title":"Writer","text":"When terminated, the file of w is closed.","category":"page"},{"location":"manual/components/sinks/writer/#","page":"Writer","title":"Writer","text":"w.file","category":"page"},{"location":"manual/components/sinks/writer/#","page":"Writer","title":"Writer","text":"note: Note\nIn this example, w does not have a plugin so the nothing has been derived or computed from the data in databuf. The data in databuf is just written to file of w. To further data processing, see Plugins","category":"page"},{"location":"manual/components/sinks/writer/#Full-API-1","page":"Writer","title":"Full API","text":"","category":"section"},{"location":"manual/components/sinks/writer/#","page":"Writer","title":"Writer","text":"Writer\nwrite!(writer::Writer, td, xd)\nread(writer::Writer; flatten=false) \nfread(path::String)\nflatten\nmv(writer::Writer, dst; force::Bool=false)\ncp(writer::Writer, dst; force=false, follow_symlinks=false)\nopen(writer::Writer)\nclose(writer::Writer)","category":"page"},{"location":"manual/components/sinks/writer/#Jusdl.Components.Sinks.Writer","page":"Writer","title":"Jusdl.Components.Sinks.Writer","text":"Writer(input::Bus; buflen=64, plugin=nothing, path=joinpath(tempdir(), string(uuid4())))\n\nConstructs a Writer whose input bus is input. buflen is the length of the internal buffer of Writer. If not nothing, plugin is used to processes the incomming data. path determines the path of the file of Writer.\n\nnote: Note\nThe type of file of Writer is JLD2.    \n\nwarning: Warning\nWhen initialized, the file of Writer is closed. See open(writer::Writer) and close(writer::Writer).\n\n\n\n\n\n","category":"type"},{"location":"manual/components/sinks/writer/#Jusdl.Utilities.write!-Tuple{Writer,Any,Any}","page":"Writer","title":"Jusdl.Utilities.write!","text":"write!(writer, td, xd)\n\nWrites xd corresponding to xd to the file of writer.\n\nExample\n\njulia> w = Writer(Bus(1))\nWriter(path:/tmp/e907d6ad-8db2-4c4a-9959-5b8d33d32156.jld2, nin:1)\n\njulia> open(w)\nWriter(path:/tmp/e907d6ad-8db2-4c4a-9959-5b8d33d32156.jld2, nin:1)\n\njulia> write!(w, 0., 10.)\n10.0\n\njulia> write!(w, 1., 20.)\n20.0\n\njulia> w.file\nJLDFile /tmp/e907d6ad-8db2-4c4a-9959-5b8d33d32156.jld2 (read/write)\n ├─🔢 0.0\n └─🔢 1.0\n\njulia> w.file[string(0.)]\n10.0\n\n\n\n\n\n","category":"method"},{"location":"manual/components/sinks/writer/#Base.read-Tuple{Writer}","page":"Writer","title":"Base.read","text":"read(writer::Writer, flatten=false)\n\nRead the contents of the file of writer and returns the sorted content of the file. If flatten is true, the content is also flattened.\n\n\n\n\n\n","category":"method"},{"location":"manual/components/sinks/writer/#Jusdl.Components.Sinks.fread-Tuple{String}","page":"Writer","title":"Jusdl.Components.Sinks.fread","text":"fread(path::String)\n\nReads the content of jld2 file and returns the sorted file content. \n\n\n\n\n\n","category":"method"},{"location":"manual/components/sinks/writer/#Jusdl.Components.Sinks.flatten","page":"Writer","title":"Jusdl.Components.Sinks.flatten","text":"flatten(content)\n\nReturns a tuple of keys and values of content.\n\n\n\n\n\n","category":"function"},{"location":"manual/components/sinks/writer/#Base.Filesystem.mv-Tuple{Writer,Any}","page":"Writer","title":"Base.Filesystem.mv","text":"mv(writer::Writer, dst; force::Bool=false)\n\nMoves the file of writer to dst. If force is true, the if dst is not a valid path, it is forced to be constructed.\n\nExample\n\njulia> mkdir(joinpath(tempdir(), \"testdir1\"))\n\"/tmp/testdir1\"\n\njulia> mkdir(joinpath(tempdir(), \"testdir2\"))\n\"/tmp/testdir2\"\n\njulia> w = Writer(Bus(), path=\"/tmp/testdir1/myfile.jld2\")\nWriter(path:/tmp/testdir1/myfile.jld2, nin:1)\n\njulia> mv(w, \"/tmp/testdir2\")\nWriter(path:/tmp/testdir2/myfile.jld2, nin:1)\n\n\n\n\n\n","category":"method"},{"location":"manual/components/sinks/writer/#Base.Filesystem.cp-Tuple{Writer,Any}","page":"Writer","title":"Base.Filesystem.cp","text":"cp(writer::Writer, dst; force=false, follow_symlinks=false)\n\nCopies the file of writer to dst. If force is true, the if dst is not a valid path, it is forced to be constructed. If follow_symlinks is true, symbolinks are followed.\n\nExample\n\njulia> mkdir(joinpath(tempdir(), \"testdir1\"))\n\"/tmp/testdir1\"\n\njulia> mkdir(joinpath(tempdir(), \"testdir2\"))\n\"/tmp/testdir2\"\n\njulia> w = Writer(Bus(), path=\"/tmp/testdir1\")\nWriter(path:/tmp/testdir1.jld2, nin:1)\n\njulia> cp(w, \"/tmp/testdir2\")\nWriter(path:/tmp/testdir2/1e72bad1-9800-4ca0-bccd-702afe75e555, nin:1)\n\n\n\n\n\n","category":"method"},{"location":"manual/components/sinks/writer/#Base.open-Tuple{Writer}","page":"Writer","title":"Base.open","text":"open(writer::Writer)\n\nOpens writer by opening the its file in  read/write mode. When writer is not openned, it is not possible to write data in writer. See also close(writer::Writer)\n\n\n\n\n\n","category":"method"},{"location":"manual/components/sinks/writer/#Base.close-Tuple{Writer}","page":"Writer","title":"Base.close","text":"close(writer::Writer)\n\nCloses writer by closing its file. When writer is closed, it is not possible to write data in writer. See also open(writer::Writer)\n\n\n\n\n\n","category":"method"},{"location":"manual/components/systems/staticsystems/subsystem/#Subsystem-1","page":"Subsystem","title":"Subsystem","text":"","category":"section"},{"location":"manual/components/systems/staticsystems/subsystem/#Construction-of-SubSystems-1","page":"Subsystem","title":"Construction of SubSystems","text":"","category":"section"},{"location":"manual/components/systems/staticsystems/subsystem/#","page":"Subsystem","title":"Subsystem","text":"A SubSystem consists of connected components. Thus, to construct a SubSystem, we first construct components, connect them and specify the input and output of SubSystem. See the basic constructor.","category":"page"},{"location":"manual/components/systems/staticsystems/subsystem/#","page":"Subsystem","title":"Subsystem","text":"SubSystem","category":"page"},{"location":"manual/components/systems/staticsystems/subsystem/#Jusdl.Components.Systems.SubSystems.SubSystem","page":"Subsystem","title":"Jusdl.Components.Systems.SubSystems.SubSystem","text":"SubSystem(components, input, output)\n\nConstructs a SubSystem consisting of components. input and output determines the inpyt and output of SubSystem. input and output may be of type Nothing, Bus of Vector{<:Link}.\n\n\n\n\n\n","category":"type"},{"location":"manual/components/systems/staticsystems/subsystem/#Basic-Operation-of-SubSystems-1","page":"Subsystem","title":"Basic Operation of SubSystems","text":"","category":"section"},{"location":"manual/components/systems/staticsystems/subsystem/#","page":"Subsystem","title":"Subsystem","text":"The operation of a SubSystem is very similar to that of a StaticSystem. The only difference is that when a SubSystem is triggered from its trigger link, it distributes the trigger to the trigger links of its components. Then, each of the components of the SubSystem takes steps individually.","category":"page"},{"location":"manual/components/systems/staticsystems/subsystem/#","page":"Subsystem","title":"Subsystem","text":"Let us construct a subsystem consisting of a generator and an adder. ","category":"page"},{"location":"manual/components/systems/staticsystems/subsystem/#","page":"Subsystem","title":"Subsystem","text":"using Jusdl # hide \ngen = ConstantGenerator()\nadder = Adder(Bus(2))","category":"page"},{"location":"manual/components/systems/staticsystems/subsystem/#","page":"Subsystem","title":"Subsystem","text":"Connect the generator and adder.","category":"page"},{"location":"manual/components/systems/staticsystems/subsystem/#","page":"Subsystem","title":"Subsystem","text":"connect(gen.output, adder.input[1])","category":"page"},{"location":"manual/components/systems/staticsystems/subsystem/#","page":"Subsystem","title":"Subsystem","text":"We are ready to construct a SubSystem.","category":"page"},{"location":"manual/components/systems/staticsystems/subsystem/#","page":"Subsystem","title":"Subsystem","text":"sub = SubSystem([gen, adder], [adder.input[2]], adder.output)","category":"page"},{"location":"manual/components/systems/staticsystems/subsystem/#","page":"Subsystem","title":"Subsystem","text":"To trigger the sub, we need to launch it,","category":"page"},{"location":"manual/components/systems/staticsystems/subsystem/#","page":"Subsystem","title":"Subsystem","text":"t = launch(sub)","category":"page"},{"location":"manual/components/systems/staticsystems/subsystem/#","page":"Subsystem","title":"Subsystem","text":"sub is ready to be triggered,","category":"page"},{"location":"manual/components/systems/staticsystems/subsystem/#","page":"Subsystem","title":"Subsystem","text":"drive(sub, 1.)","category":"page"},{"location":"manual/components/systems/staticsystems/subsystem/#","page":"Subsystem","title":"Subsystem","text":"Put some data to the input of sub.","category":"page"},{"location":"manual/components/systems/staticsystems/subsystem/#","page":"Subsystem","title":"Subsystem","text":"put!(sub.input, [1.])","category":"page"},{"location":"manual/components/systems/staticsystems/subsystem/#","page":"Subsystem","title":"Subsystem","text":"The step needs to be approved.","category":"page"},{"location":"manual/components/systems/staticsystems/subsystem/#","page":"Subsystem","title":"Subsystem","text":"approve(sub)","category":"page"},{"location":"manual/components/systems/staticsystems/subsystem/#","page":"Subsystem","title":"Subsystem","text":"Now print the data written to the outputs of the components of sub.","category":"page"},{"location":"manual/components/systems/staticsystems/subsystem/#","page":"Subsystem","title":"Subsystem","text":"sub.components[1].output[1].buffer.data[1]\nsub.components[2].output[1].buffer.data[1]","category":"page"},{"location":"manual/components/systems/staticsystems/subsystem/#","page":"Subsystem","title":"Subsystem","text":"Note that when sub is triggered, sub transfer the trigger to all its internal components.","category":"page"},{"location":"manual/models/model/#Model-1","page":"Model","title":"Model","text":"","category":"section"},{"location":"manual/models/model/#Signal-Flow-Approach-in-Modelling-1","page":"Model","title":"Signal-Flow Approach in Modelling","text":"","category":"section"},{"location":"manual/models/model/#","page":"Model","title":"Model","text":"Jusdl adopts signal-flow approach in systems modelling. In signal-flow approach, a Model consists of connected components. The components are data processing units and the behavior, i.e, the mathematical model, of the component determines how the data is processed. Connections connects the components each other and the data is transferred between components by means of connections. The data flow through the connections is unidirectional, i.e., a component is driven by other components that write data to its input bus. ","category":"page"},{"location":"manual/models/model/#Construction-of-Models-1","page":"Model","title":"Construction of Models","text":"","category":"section"},{"location":"manual/models/model/#","page":"Model","title":"Model","text":"A Model consists of connected components. Here is the constructor, ","category":"page"},{"location":"manual/models/model/#","page":"Model","title":"Model","text":"Model","category":"page"},{"location":"manual/models/model/#Jusdl.Models.Model","page":"Model","title":"Jusdl.Models.Model","text":"Model(blocks::AbstractVector)\n\nConstructs a Model whose with components blocks which are of type AbstractComponent.\n\nModel()\n\nConstructs a Model with empty components. After the construction, components can be added to Model.\n\nwarning: Warning\nModels are units that can be simulated. As the data flows through the connections i.e. input output busses of the components, its is important that the components must be connected to each other. See also: simulate\n\n\n\n\n\n","category":"type"},{"location":"manual/models/model/#","page":"Model","title":"Model","text":"That is, the components of are defined first and the Model consisting of these components can be constructed. Or, an empty model can be constructed. ","category":"page"},{"location":"manual/models/model/#","page":"Model","title":"Model","text":"Let us continue with some examples. We will construct very simple Model consisting of a SinewaveGenerator and a Writer. We construct the components first.","category":"page"},{"location":"manual/models/model/#","page":"Model","title":"Model","text":"using Jusdl # hide \ngen = SinewaveGenerator()\nwriter = Writer(Bus())","category":"page"},{"location":"manual/models/model/#","page":"Model","title":"Model","text":"Next, we construct the model","category":"page"},{"location":"manual/models/model/#","page":"Model","title":"Model","text":"model = Model(gen, writer)","category":"page"},{"location":"manual/models/model/#","page":"Model","title":"Model","text":"The other way is to construct an empty Model, that is a Model with no components, and then add components later. ","category":"page"},{"location":"manual/models/model/#","page":"Model","title":"Model","text":"using Jusdl # hide \nmodel = Model()\naddcomponent(model, SinewaveGenerator())\naddcomponent(model, Writer())","category":"page"},{"location":"manual/models/model/#Simulation-of-Models-1","page":"Model","title":"Simulation of Models","text":"","category":"section"},{"location":"manual/models/model/#","page":"Model","title":"Model","text":"A Model to to be simulated consists of components connected to each other an a time reference.","category":"page"},{"location":"manual/models/model/#","page":"Model","title":"Model","text":"model.blocks    # Model components \nmodel.clk       # Model time reference","category":"page"},{"location":"manual/models/model/#","page":"Model","title":"Model","text":"The time reference is used to sample the continuous time signals flowing through the busses of the model and to rigger the components. The simulation is performed by triggering the components with the pulses generated by the time reference at simulation sampling time intervals. Having been triggered, the components evolve themselves, compute their outputs and writes them to their outputs.","category":"page"},{"location":"manual/models/model/#Simulation-Stages-1","page":"Model","title":"Simulation Stages","text":"","category":"section"},{"location":"manual/models/model/#Inspection-1","page":"Model","title":"Inspection","text":"","category":"section"},{"location":"manual/models/model/#","page":"Model","title":"Model","text":"The inspection stage is the first stage of the simulation process. In this stag,e the model is first inspected in terms of whether it is ready for simulation. This inspection is carried out to see whether the model has some inconsistencies such as unterminated busses or presence of algebraic loops. If the model has unterminated busses, the data that is supposed to flow those unterminated busses cannot flow through those busses and the simulation gets stuck. An algebraic is the subset of model components whose output depends directly on their inputs. In such a case, none of the components can produce outputs to break the loop which leads again the obstruction of simulation. Thus, to continue the simulation, the model must not contain any of those inconsistencies. The model inspection is done with inspect function.","category":"page"},{"location":"manual/models/model/#","page":"Model","title":"Model","text":"inspect","category":"page"},{"location":"manual/models/model/#Jusdl.Models.inspect","page":"Model","title":"Jusdl.Models.inspect","text":"inspect(model::Model)\n\nInspects the model. If model has some inconsistencies such as including algebraic loops or unterminated busses and error is thrown.\n\n\n\n\n\n","category":"function"},{"location":"manual/models/model/#Initialization-1","page":"Model","title":"Initialization","text":"","category":"section"},{"location":"manual/models/model/#","page":"Model","title":"Model","text":"If the inspection stage results positive, the initialization stage comes next. In this stage, the tasks required for the busses of the model to be both readable and writable are activated and bound the busses. To this end, a reader and writer task are activated and bound to both sides of each bus. To initialize the model, initialize function is used. ","category":"page"},{"location":"manual/models/model/#","page":"Model","title":"Model","text":"initialize","category":"page"},{"location":"manual/models/model/#Jusdl.Models.initialize","page":"Model","title":"Jusdl.Models.initialize","text":"initialize(model::Model)\n\nInitializes model by launching component task for each of the component of model. The pairs component and component tasks are recordedin the task manager of the model. See also: ComponentTask, TaskManager. The model clock is set! and the files of Writer are openned.\n\n\n\n\n\n","category":"function"},{"location":"manual/models/model/#","page":"Model","title":"Model","text":"When the model is initialized, the pairs of components and component tasks are recorded into the task manager of the model. During the rest of the simulation, task manager keeps track of the tasks. Any exception or error that is thrown during the run stage of the simulation can be observed by means of the task manager of the model.","category":"page"},{"location":"manual/models/model/#Run-1","page":"Model","title":"Run","text":"","category":"section"},{"location":"manual/models/model/#","page":"Model","title":"Model","text":"The run stage follows the initialization stage. The tasks activated in the initialization stage wait for the components to be triggered by the model time reference. During the run stage, time reference, that is the model clock, triggers the components by writing pulses that are generated in the intervals of the sampling period of the simulation to their trigger links. The job defined in a task is to read input dat a from the its input bus, to calculate its next state, if any, and output, and write its calculated output to its output bus. The run stage, starts at the initial time of the time reference and continues until the end time of the time reference. run function is used to run the models, ","category":"page"},{"location":"manual/models/model/#","page":"Model","title":"Model","text":"run(model::Model)","category":"page"},{"location":"manual/models/model/#Base.run-Tuple{Model}","page":"Model","title":"Base.run","text":"run(model::Model)\n\nRuns the model by triggering the components of the model. This triggering is done by generating clock tick using the model clock model.clk. Triggering starts with initial time of model clock, goes on with a step size of the sampling period of the model clock, and finishes at the finishing time of the model clock. \n\nwarning: Warning\nThe model must first be initialized to be run. See also: initialize.\n\n```\n\n\n\n\n\n","category":"method"},{"location":"manual/models/model/#Termination-1","page":"Model","title":"Termination","text":"","category":"section"},{"location":"manual/models/model/#","page":"Model","title":"Model","text":"After the run stage, the tasks opened in the initialization stage are closed and the simulation is terminated. terminate function is used to terminate the model ","category":"page"},{"location":"manual/models/model/#","page":"Model","title":"Model","text":"terminate","category":"page"},{"location":"manual/models/model/#","page":"Model","title":"Model","text":"Models are constructed to simulate them. During the simulation, components of the Model process data and the data is transferred between the components via connection. Thus, to simulate the Models, the components must be connected. Hence, we connect the components. ","category":"page"},{"location":"manual/models/model/#","page":"Model","title":"Model","text":"connect(gen.output, writer.input)","category":"page"},{"location":"manual/models/model/#","page":"Model","title":"Model","text":"In our model, the writer is used to record the output of gen. Thus, the flows from gen to writer. Thus, we connect gen output to writer input. ","category":"page"},{"location":"manual/models/model/#","page":"Model","title":"Model","text":"note: Note\nDuring the Model construction, the order of components are not important. The components cane be given in any order. For instance, in the example above, the Model can be constructed as model = Model(writer, gen).","category":"page"},{"location":"manual/models/model/#Full-API-1","page":"Model","title":"Full API","text":"","category":"section"},{"location":"manual/models/model/#","page":"Model","title":"Model","text":"addcomponent\nrelease(model::Model)\nfindin\nsimulate","category":"page"},{"location":"manual/models/model/#Jusdl.Models.addcomponent","page":"Model","title":"Jusdl.Models.addcomponent","text":"addcomponent(model::Model, comp::AbstractComponent)\n\nAdds comp to model components.\n\nExample\n\njulia> m = Model()\nModel(blocks:Any[])\n\njulia> addcomponent(m, SinewaveGenerator())\n1-element Array{Any,1}:\n SinewaveGenerator(amp:1.0, freq:1.0, phase:0.0, offset:0.0, delay:0.0)\n\n\n\n\n\n","category":"function"},{"location":"manual/models/model/#Jusdl.Connections.release-Tuple{Model}","page":"Model","title":"Jusdl.Connections.release","text":"release(model::Model)\n\nReleaes the each component of model, i.e., the input and output bus of each component is released.\n\n\n\n\n\n","category":"method"},{"location":"manual/models/model/#Jusdl.Models.findin","page":"Model","title":"Jusdl.Models.findin","text":"findin(model::Model, id::UUID)\n\nReturns the component of the model corresponding whose id is id.\n\nfindin(model::Model, comp::AbstractComponent)\n\nReturns the compeonent whose variable name is comp.\n\n\n\n\n\n","category":"function"},{"location":"manual/models/model/#Jusdl.Models.simulate","page":"Model","title":"Jusdl.Models.simulate","text":"simulate(model::Model;  simdir::String=\"/tmp\", logtofile::Bool=false, reportsim::Bool=false)\n\nSimulates model. simdir is the path of the directory into which simulation files are saved. If logtofile is true, a log file for the simulation is constructed. If reportsim is true, model components are saved into files.\n\n\n\n\n\nsimulate(model::Model, t0::Real, dt::Real, tf::Real; kwargs...)\n\nSimulates the model starting from the initial time t0 until the final time tf with the sampling interval of tf. For kwargs are \n\nlogtofile::Bool: If true, a log file is contructed logging each step of the simulation. \nreportsim::Bool: If true, model components are written files after the simulation. When this file is read back, the model components can be consructed back with their status at the end of the simulation.\nsimdir::String: The path of the directory in which simulation file are recorded. \n\n\n\n\n\n","category":"function"},{"location":"manual/components/systems/staticsystems/staticsystems/#StaticSystems-1","page":"StaticSystems","title":"StaticSystems","text":"","category":"section"},{"location":"manual/components/systems/staticsystems/staticsystems/#Basic-Operation-of-StaticSystems-1","page":"StaticSystems","title":"Basic Operation of StaticSystems","text":"","category":"section"},{"location":"manual/components/systems/staticsystems/staticsystems/#","page":"StaticSystems","title":"StaticSystems","text":"Static systems are the systems whose output y at time t depends on the current time t and the value of their inputs u. The input-output relation of static systems are represented by their output function outputfunc which is of the form ","category":"page"},{"location":"manual/components/systems/staticsystems/staticsystems/#","page":"StaticSystems","title":"StaticSystems","text":"    y = g(u t)","category":"page"},{"location":"manual/components/systems/staticsystems/staticsystems/#","page":"StaticSystems","title":"StaticSystems","text":"where g is the output function outputfunc. Note that outputfunc is expected to have two inputs, the value u of the input and the current time t. The simulation in Jusdl is a clocked-simulation, that is the data flowing through the input and output connections of components is actually sampled at time t. Therefore, for example, the system modelled by","category":"page"},{"location":"manual/components/systems/staticsystems/staticsystems/#","page":"StaticSystems","title":"StaticSystems","text":"y(t) = g(u(t)t)","category":"page"},{"location":"manual/components/systems/staticsystems/staticsystems/#","page":"StaticSystems","title":"StaticSystems","text":"is actually sampled at clock ticks t which is generated by a Clock. Therefore the sampled system corresponds to","category":"page"},{"location":"manual/components/systems/staticsystems/staticsystems/#","page":"StaticSystems","title":"StaticSystems","text":"yk = g(u_k t_k)","category":"page"},{"location":"manual/components/systems/staticsystems/staticsystems/#","page":"StaticSystems","title":"StaticSystems","text":"where k is k_i T_s where k_i is an integer number, T_s is the sampling interval. T_s corresponds to sampling time dt of Clock. Thus, the system given above is coded like ","category":"page"},{"location":"manual/components/systems/staticsystems/staticsystems/#","page":"StaticSystems","title":"StaticSystems","text":"function g(u, t)\n    # Define the relation `y = g(u, t)`\nend","category":"page"},{"location":"manual/components/systems/staticsystems/staticsystems/#","page":"StaticSystems","title":"StaticSystems","text":"For further clarity, let us continue with a case study. Consider the following static system,","category":"page"},{"location":"manual/components/systems/staticsystems/staticsystems/#","page":"StaticSystems","title":"StaticSystems","text":"    y(t) = g(u(t) t) = left\n        beginarrayl\n            t u_1(t) \n            sin(u_1(t))  \n            cos(u_2(t))\n        endarray\n        right","category":"page"},{"location":"manual/components/systems/staticsystems/staticsystems/#","page":"StaticSystems","title":"StaticSystems","text":"Note that the number of inputs is 2 and the number of outputs of is 3. To define such a system, the output function is written as","category":"page"},{"location":"manual/components/systems/staticsystems/staticsystems/#","page":"StaticSystems","title":"StaticSystems","text":"using Jusdl # hide\ng(u, t) = [t * u[1], sin(u[1]), cos(u[2])]","category":"page"},{"location":"manual/components/systems/staticsystems/staticsystems/#","page":"StaticSystems","title":"StaticSystems","text":"Note that the function g is defined such a way that the input value u is sampled, which implies u is not vector of function but is a vector of real. Having defined output function outputfunc, the system can be constructed. ","category":"page"},{"location":"manual/components/systems/staticsystems/staticsystems/#","page":"StaticSystems","title":"StaticSystems","text":"ss = StaticSystem(Bus(2), Bus(3), g)","category":"page"},{"location":"manual/components/systems/staticsystems/staticsystems/#","page":"StaticSystems","title":"StaticSystems","text":"Note the construction of input bus Bus(2) and output bus Bus(3) by recalling that the number of input is 2 and the number of output is 3.","category":"page"},{"location":"manual/components/systems/staticsystems/staticsystems/#","page":"StaticSystems","title":"StaticSystems","text":"A StaticSystem operates by being triggered from its trigger link. When triggered from its trigger link, a StaticSystem read the current time t from its trigger link and computes its output y according to its output function outputfunc and writes its output t to its output bus (If output bus exists since output bus may not have depending on the relation defined by outputfunc. When constructed, a StaticSystem is not ready to be triggered since its trigger link is not writeable. ","category":"page"},{"location":"manual/components/systems/staticsystems/staticsystems/#","page":"StaticSystems","title":"StaticSystems","text":"ss.trigger","category":"page"},{"location":"manual/components/systems/staticsystems/staticsystems/#","page":"StaticSystems","title":"StaticSystems","text":"To make ss drivable, we need to launch ss. ","category":"page"},{"location":"manual/components/systems/staticsystems/staticsystems/#","page":"StaticSystems","title":"StaticSystems","text":"task = launch(ss)","category":"page"},{"location":"manual/components/systems/staticsystems/staticsystems/#","page":"StaticSystems","title":"StaticSystems","text":"Now, ss is drivable from its trigger link. ","category":"page"},{"location":"manual/components/systems/staticsystems/staticsystems/#","page":"StaticSystems","title":"StaticSystems","text":"ss.trigger","category":"page"},{"location":"manual/components/systems/staticsystems/staticsystems/#","page":"StaticSystems","title":"StaticSystems","text":"Now let us drive ss.","category":"page"},{"location":"manual/components/systems/staticsystems/staticsystems/#","page":"StaticSystems","title":"StaticSystems","text":"put!(ss.trigger, 1.)","category":"page"},{"location":"manual/components/systems/staticsystems/staticsystems/#","page":"StaticSystems","title":"StaticSystems","text":"As this point ss wait for its to be written. Let us write some data to input of ss.","category":"page"},{"location":"manual/components/systems/staticsystems/staticsystems/#","page":"StaticSystems","title":"StaticSystems","text":"put!(ss.input, [10., 10.])","category":"page"},{"location":"manual/components/systems/staticsystems/staticsystems/#","page":"StaticSystems","title":"StaticSystems","text":"ss read the value u of its input , read the current time t, and computed its output value y and wrote it its output. To signal that it succeeded to be take the step, it put a true to its handshake which needs to be taken.","category":"page"},{"location":"manual/components/systems/staticsystems/staticsystems/#","page":"StaticSystems","title":"StaticSystems","text":"ss.handshake\ntake!(ss.handshake)","category":"page"},{"location":"manual/components/systems/staticsystems/staticsystems/#","page":"StaticSystems","title":"StaticSystems","text":"We can see the current data in the output of ss.","category":"page"},{"location":"manual/components/systems/staticsystems/staticsystems/#","page":"StaticSystems","title":"StaticSystems","text":"println(ss.output[1].buffer.data)","category":"page"},{"location":"manual/components/systems/staticsystems/staticsystems/#","page":"StaticSystems","title":"StaticSystems","text":"Let us further drive ss.","category":"page"},{"location":"manual/components/systems/staticsystems/staticsystems/#","page":"StaticSystems","title":"StaticSystems","text":"for t in 2. : 10.\n    put!(ss.trigger, t)\n    put!(ss.input, [10 * t, 20 * t])\n    take!(ss.handshake)\nend","category":"page"},{"location":"manual/components/systems/staticsystems/staticsystems/#","page":"StaticSystems","title":"StaticSystems","text":"The data written to the output of ss is also written to the internal buffers of output.","category":"page"},{"location":"manual/components/systems/staticsystems/staticsystems/#","page":"StaticSystems","title":"StaticSystems","text":"println(ss.output[1].buffer.data)","category":"page"},{"location":"manual/components/systems/staticsystems/staticsystems/#Full-API-1","page":"StaticSystems","title":"Full API","text":"","category":"section"},{"location":"manual/components/systems/staticsystems/staticsystems/#","page":"StaticSystems","title":"StaticSystems","text":"StaticSystem \nAdder\nMultiplier\nGain\nTerminator\nMemory\nCoupler","category":"page"},{"location":"manual/components/systems/staticsystems/staticsystems/#Jusdl.Components.Systems.StaticSystems.StaticSystem","page":"StaticSystems","title":"Jusdl.Components.Systems.StaticSystems.StaticSystem","text":"StaticSystem(input, output, outputfunc)\n\nConstruts a StaticSystem with input input, output output and output function outputfunc. outputfunc is a two-argument function of the form\n\n    y = g(u t)\n\nwhere g is outputfunc, t is the time, u is the input at time t and y is the output at time t.  input and output may be nothing depending on relation defined in outputfunc.\n\nExample\n\njulia> g(u, t) = [u[1] + u[2], sin(u[2]), cos([1])]  # The system has 2 inputs and 3 outputs.\ng (generic function with 1 method)\n\njulia> ss = StaticSystem(Bus(2), Bus(3), g)\nStaticSystem(outputfunc:g, input:Bus(nlinks:2, eltype:Link{Float64}, isreadable:false, iswritable:false), output:Bus(nlinks:3, eltype:Link{Float64}, isreadable:false, iswritable:false))\n\njulia> g2(u, t) = t  # The system does not have any input.\ng2 (generic function with 1 method)\n\njulia> ss2 = StaticSystem(nothing, Bus(), g2)\nStaticSystem(outputfunc:g2, input:nothing, output:Bus(nlinks:1, eltype:Link{Float64}, isreadable:false, iswritable:false))\n\n\n\n\n\n","category":"type"},{"location":"manual/components/systems/staticsystems/staticsystems/#Jusdl.Components.Systems.StaticSystems.Adder","page":"StaticSystems","title":"Jusdl.Components.Systems.StaticSystems.Adder","text":"Adder(input::Bus[, signs])\n\nConstruts an Adder with input bus input and signs signs. signs is a tuplle of + and/or -. The output function g of Adder is of the form,\n\n    y = g(u t) =  sum_j = 1^n s_k u_k\n\nwhere n is the length of the input, s_k is the kth element of signs, u_k is the kth value of input and y is the value of output. The default value of signs is all +.\n\nExample\n\njulia> adder = Adder(Bus(3), (+, +, -));\n\njulia> adder.outputfunc([3, 4, 5], 0.) == 3 + 4 - 5\ntrue\n\n\n\n\n\n","category":"type"},{"location":"manual/components/systems/staticsystems/staticsystems/#Jusdl.Components.Systems.StaticSystems.Multiplier","page":"StaticSystems","title":"Jusdl.Components.Systems.StaticSystems.Multiplier","text":"Multiplier(input::Bus[, ops])\n\nConstruts an Multiplier with input bus input and signs signs. signs is a tuplle of * and/or /. The output function g of Multiplier is of the form,\n\n    y = g(u t) =  prod_j = 1^n s_k u_k\n\nwhere n is the length of the input, s_k is the kth element of signs, u_k is the kth value of input and y is the value of the output. The default value of signs is all *.\n\nExample\n\njulia> mlt = Multiplier(Bus(3), (*, *, /));\n\njulia> mlt.outputfunc([3, 4, 5], 0.) == 3 * 4 / 5\ntrue\n\n\n\n\n\n","category":"type"},{"location":"manual/components/systems/staticsystems/staticsystems/#Jusdl.Components.Systems.StaticSystems.Gain","page":"StaticSystems","title":"Jusdl.Components.Systems.StaticSystems.Gain","text":"Gain(input; gain=1.)\n\nConstructs a Gain whose output function g is of the form \n\n    y = g(u t) =  K u\n\nwhere K is gain, u is the value of input and y is the value of output.\n\nExample\n\njulia> K = [1. 2.; 3. 4.];\n\njulia> g = Gain(Bus(2), gain=K);\n\njulia> g.outputfunc([1., 2.], 0.) == K * [1., 2.]\ntrue\n\n\n\n\n\n","category":"type"},{"location":"manual/components/systems/staticsystems/staticsystems/#Jusdl.Components.Systems.StaticSystems.Terminator","page":"StaticSystems","title":"Jusdl.Components.Systems.StaticSystems.Terminator","text":"Terminator(input::Bus)\n\nConstructs a Terminator with input bus input. The output function g is eqaul to nothing. A Terminator is used just to sink the incomming data flowing from its input.\n\n\n\n\n\n","category":"type"},{"location":"manual/components/systems/staticsystems/staticsystems/#Jusdl.Components.Systems.StaticSystems.Memory","page":"StaticSystems","title":"Jusdl.Components.Systems.StaticSystems.Memory","text":"Memory(input::Bus{Union{Missing, T}}, numdelay::Int; initial=Vector{T}(undef, length(input)))\n\nConstructs a 'Memorywith input businput. A 'Memory delays the values of input by an amount of numdelay. initial determines the transient output from the Memory, that is, until the internal buffer of Memory is full, the values from initial is returned.\n\n\n\n\n\n","category":"type"},{"location":"manual/components/systems/staticsystems/staticsystems/#Jusdl.Components.Systems.StaticSystems.Coupler","page":"StaticSystems","title":"Jusdl.Components.Systems.StaticSystems.Coupler","text":"Coupler(conmat::AbstractMatrix, cplmat::AbstractMatrix)\n\nConstructs a coupler from connection matrix conmat of size n times n and coupling matrix cplmat of size d times d. The output function g of Coupler is of the form \n\n    y = g(u t) = (E otimmes P) u\n\nwhere otimes is the Kronecker product, E is conmat and P is cplmat, u is the value of input and y is the value of output.\n\n\n\n\n\n","category":"type"},{"location":"manual/components/systems/dynamicsystems/daesystem/#DAESystem-1","page":"DAESystem","title":"DAESystem","text":"","category":"section"},{"location":"manual/components/systems/dynamicsystems/daesystem/#Full-API-1","page":"DAESystem","title":"Full API","text":"","category":"section"},{"location":"manual/components/systems/dynamicsystems/daesystem/#","page":"DAESystem","title":"DAESystem","text":"DAESystem","category":"page"},{"location":"manual/components/systems/dynamicsystems/daesystem/#Jusdl.Components.Systems.DynamicSystems.DAESystem","page":"DAESystem","title":"Jusdl.Components.Systems.DynamicSystems.DAESystem","text":"DAESystem(input, output, statefunc, outputfunc, state, stateder, t, diffvars; solver=DAESolver)\n\nConstrusts a DAESystem with input and output. statefunc is the state function and outputfunc is the output function. DAESystem is represented by the following equations. \n\n    beginarrayl\n        0 = f(out dx x u t) \n        y = f(x u t)\n    endarray\n\nwhere t is the time t, x is state,  dx is the value of the derivative of the state stateder, u is the value of input and y is the value of output at time t. solver is used to solve the above differential equation.\n\nThe signature of statefunc must be of the form \n\nfunction statefunc(out, dx, x, u, t)\n    out .= ... # Update out\nemd\n\nand the signature of outputfunc must be of the form \n\nfunction outputfunc(x, u, t)\n    y = ... # Compute y \n    return y\nend\n\n\n\n\n\n","category":"type"},{"location":"tutorials/simple_model/#Construction-and-Simulation-of-a-Simple-Model-1","page":"Simple Model Simulation","title":"Construction and Simulation of a Simple Model","text":"","category":"section"},{"location":"tutorials/simple_model/#","page":"Simple Model Simulation","title":"Simple Model Simulation","text":"It this tutorial, we will simulate a very simple model consisting of a sinusoidal generator and a writer.  ","category":"page"},{"location":"tutorials/simple_model/#Model-Construction-1","page":"Simple Model Simulation","title":"Model Construction","text":"","category":"section"},{"location":"tutorials/simple_model/#","page":"Simple Model Simulation","title":"Simple Model Simulation","text":"A model consists of connected components. We can either construct the components first and then connect them together to construct the model, or, we construct an empty model with no components, construct the components, connect those components and add those connected components to the model.","category":"page"},{"location":"tutorials/simple_model/#Construction-of-Model-Construct-the-Components-First-1","page":"Simple Model Simulation","title":"Construction of Model - Construct the Components First","text":"","category":"section"},{"location":"tutorials/simple_model/#","page":"Simple Model Simulation","title":"Simple Model Simulation","text":"We construct the components first and then connect them together","category":"page"},{"location":"tutorials/simple_model/#","page":"Simple Model Simulation","title":"Simple Model Simulation","text":"using Jusdl \n\n# Construction of the components \ngen = SinewaveGenerator()\nwriter = Writer(Bus())\n\n# Connection of components \nconnect(gen.output, writer.input)\n\n# Construction of the model \nmodel = Model(gen, writer)","category":"page"},{"location":"tutorials/simple_model/#","page":"Simple Model Simulation","title":"Simple Model Simulation","text":"In this simple model, we have a single output sinusoidal wave generator gen and a writer. In the script above, we constructed the components, connected them together and constructed the model. ","category":"page"},{"location":"tutorials/simple_model/#Construction-of-Model-Construct-the-Model-First-1","page":"Simple Model Simulation","title":"Construction of Model - Construct the Model First","text":"","category":"section"},{"location":"tutorials/simple_model/#","page":"Simple Model Simulation","title":"Simple Model Simulation","text":"In this way, we construct and empty model and then construct components, connect them and add them to the model ","category":"page"},{"location":"tutorials/simple_model/#","page":"Simple Model Simulation","title":"Simple Model Simulation","text":"using Jusdl \n\n# Construct the model with no components\nmodel = Model()\n\n\n# Construct the components \ngen = SinewaveGenerator()\nwriter = Writer(Bus())\n\n# Connect the components \nconnect(gen.output, writer.input)\n\n# Add components to model \naddcomponent(model, gen)\naddcomponent(model, writer)","category":"page"},{"location":"tutorials/simple_model/#Model-Simulation-1","page":"Simple Model Simulation","title":"Model Simulation","text":"","category":"section"},{"location":"tutorials/simple_model/#","page":"Simple Model Simulation","title":"Simple Model Simulation","text":"To simulate a model, simulation time settings are mandatory,","category":"page"},{"location":"tutorials/simple_model/#","page":"Simple Model Simulation","title":"Simple Model Simulation","text":"\n# Define simulation time settings \nt0 = 0.     # Start time \ndt = 0.01   # Sampling interval\ntf = 10.    # Final time","category":"page"},{"location":"tutorials/simple_model/#","page":"Simple Model Simulation","title":"Simple Model Simulation","text":"Next, we can specify other simulation settings such as whether a simulation log file are to constructed, model blocks are to saved in a file, etc. ","category":"page"},{"location":"tutorials/simple_model/#","page":"Simple Model Simulation","title":"Simple Model Simulation","text":"simdir = \"/tmp\"     # Path in which simulation files are saved.\nlogtofile = true    # If true, a simulation log file is constructed \nreportsim = true    # If true, model blocks are saved.","category":"page"},{"location":"tutorials/simple_model/#","page":"Simple Model Simulation","title":"Simple Model Simulation","text":"At this point, we are ready to simulate the model,","category":"page"},{"location":"tutorials/simple_model/#","page":"Simple Model Simulation","title":"Simple Model Simulation","text":"sim = simulate(model, t0, dt, tf, simdir=simdir, logtofile=logtofile, reportsim=reportsim)","category":"page"},{"location":"tutorials/simple_model/#Investigation-of-Simulation-1","page":"Simple Model Simulation","title":"Investigation of Simulation","text":"","category":"section"},{"location":"tutorials/simple_model/#","page":"Simple Model Simulation","title":"Simple Model Simulation","text":"First, let us observe Simulation instance sim. We start with the directory in which all simulation files are saved.  ","category":"page"},{"location":"tutorials/simple_model/#","page":"Simple Model Simulation","title":"Simple Model Simulation","text":"@show sim.path","category":"page"},{"location":"tutorials/simple_model/#","page":"Simple Model Simulation","title":"Simple Model Simulation","text":"Now change directory to sim.path and print the content of the log fle.","category":"page"},{"location":"tutorials/simple_model/#","page":"Simple Model Simulation","title":"Simple Model Simulation","text":"# Change directory to simulation path. \ncd(sim.path)\n\n# Print the contents of log file \nopen(\"log.txt\", \"r\") do file \n    for line in readlines(file)\n        println(line)\n    end\nend","category":"page"},{"location":"tutorials/simple_model/#Analysis-of-Simulation-Data-Files-1","page":"Simple Model Simulation","title":"Analysis of Simulation Data Files","text":"","category":"section"},{"location":"tutorials/simple_model/#","page":"Simple Model Simulation","title":"Simple Model Simulation","text":"After the simulation, the data saved in simulation data files, i.e. in the files of writers, can be read back any offline data analysis can be performed. ","category":"page"},{"location":"tutorials/simple_model/#","page":"Simple Model Simulation","title":"Simple Model Simulation","text":"# Read the simulation data\nt, x = read(writer, flatten=true) \n\n# Plot the data\nusing Plots \ntheme(:default)\nplot(t, x, xlabel=\"t\", ylabel=\"x\", label=\"\")","category":"page"},{"location":"#Jusdl-1","page":"Home","title":"Jusdl","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"This is the official documentation of Jusdl that enables fast and effective systems simulations together with online and offline data analysis. In Jusdl, it is possible to simulate discrete time and continuous time, static or dynamical systems. In particular, it is possible to simulate dynamical systems modeled by different types of differential equations such as ODE (Ordinary Differential Equation), Random Ordinary Differential Equation (RODE), SDE (Stochastic Differential Equation), DDE (Delay Differential Equation) and DAE (Differential Algebraic Equation), and discrete difference equations. During the simulation, the data flowing through the links of the model can processed online and offline and specialized analyzes can be performed. These analyzes can also be enriched with plugins that can easily be defined using the standard Julia library or various Julia packages. The simulation is done with the parallel evolution of the model components individually and sampling sampling time intervals. The individual evolution of the components allows the simulation of the models including the components that are represented by different kinds of mathematical equations while the parallel evolution of components increases the simulation speed. ","category":"page"},{"location":"#Installation-1","page":"Home","title":"Installation","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"Installation of Jusdl is the similar to any Julia package. Just add from the repository [https://imel.eee.deu.edu.tr/git/JuSDL.jl.git]. Start a Julia session and type,","category":"page"},{"location":"#","page":"Home","title":"Home","text":"using Pkg \nPkg.add(PackageSpec(url=\"https://imel.eee.deu.edu.tr/git/JuSDL.jl.git\"))","category":"page"}]
}
